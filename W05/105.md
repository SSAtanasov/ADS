# 📚 Упражнение № 05: Рекурсивни алгоритми

## 🎯 Пълно методическо ръководство с детайлни обяснения и визуализации

**От функции до рекурсия - всичко обяснено стъпка по стъпка**

---

## 📋 Съдържание

### Основи:
1. [Функции в C++](#functions) - Какво са и как работят
2. [Параметри и return](#params) - Предаване и връщане на стойности
3. [void функции](#void) - Функции без връщана стойност

### Рекурсия:
4. [Какво е рекурсия?](#recursion-intro) - Идеята зад рекурсията
5. [Call Stack](#call-stack) - Как работи стекът на извикванията
6. [Задача 105-3: Сума 1 до n](#sum) - Първа рекурсивна функция
7. [Задача 105-4: Fibonacci](#fibonacci) - Класическа рекурсия
8. [Задача 105-5: QuickSort](#quicksort) - Рекурсивна сортировка

### Допълнително:
9. [Анализ на сложността](#complexity) - Времева и памета сложност
10. [Рекурсия vs Итерация](#recursion-vs-iteration) - Кога какво да използваме
11. [Често срещани грешки](#common-mistakes) - Как да ги избегнем

---

<a name="functions"></a>
## 📌 ЧАСТ 1: Функции в C++

### 🎯 Какво е функция?

**Функция** е блок от код, който изпълнява определена задача и може да бъде **преизползван** многократно.

🔑 **Защо са важни функциите?**
- ✅ **Преизползваемост** - пишем код веднъж, използваме го многократно
- ✅ **Четимост** - кодът е по-разбираем и организиран
- ✅ **Модулност** - разделяме сложни задачи на по-прости части
- ✅ **Поддръжка** - лесно се поправят грешки

### 📝 Синтаксис на функция

```cpp
тип_на_резултата име_на_функция(списък_от_параметри) {
    // тяло на функцията
    // код, който се изпълнява
    
    return израз;  // връща резултат (ако не е void)
}
```

**Компонентите на функцията:**

```
┌─────────────────────────────────────────────────────────┐
│ int   maxOfTwo  (int num1, int num2)  {  return ...  } │
│ ↑        ↑           ↑                     ↑            │
│ │        │           │                     │            │
│ тип    име      параметри            връщане          │
└─────────────────────────────────────────────────────────┘

1. ТИП (int)        - какво връща функцията
2. ИМЕ (maxOfTwo)   - как се казва
3. ПАРАМЕТРИ        - какво получава
4. RETURN           - какво връща
```

### 🎬 Пример 1: Проста функция

```cpp
#include <iostream>
using namespace std;

// Функция за събиране на две числа
int sum(int a, int b) {
    return a + b;
}

int main() {
    int result = sum(3, 5);  // Извикване на функцията
    cout << "3 + 5 = " << result << endl;  // Изход: 8
    return 0;
}
```

**Визуализация на изпълнението:**

```
═══════════════════════════════════════════════════════════
ИЗПЪЛНЕНИЕ СТЪПКА ПО СТЪПКА:
═══════════════════════════════════════════════════════════

Стъпка 1: Програмата стартира от main()
┌─────────────────────┐
│ main()              │
│                     │
│ result = sum(3, 5) │ ← Извикваме функцията
└─────────────────────┘

Стъпка 2: Скачаме в функцията sum()
┌─────────────────────┐
│ sum(a=3, b=5)       │ ← Параметрите получават стойности
│                     │
│ return 3 + 5        │ ← Изчисляваме
│ return 8            │ ← Връщаме резултат
└─────────────────────┘

Стъпка 3: Връщаме се в main()
┌─────────────────────┐
│ main()              │
│                     │
│ result = 8          │ ← Получаваме резултата
│ cout << 8           │ ← Отпечатваме
└─────────────────────┘

РЕЗУЛТАТ: 3 + 5 = 8 ✅
═══════════════════════════════════════════════════════════
```

---

<a name="params"></a>
## 📌 Параметри на функциите

### 🔄 Формални vs Фактически параметри

```cpp
//          Формални параметри
//          ↓           ↓
int maxOfTwo(int num1, int num2) {
    if (num1 > num2)
        return num1;
    else
        return num2;
}

int main() {
    int a = 10, b = 20;
    //                Фактически параметри
    //                ↓   ↓
    int max = maxOfTwo(a, b);  // или maxOfTwo(10, 20)
}
```

**Обяснение:**

```
╔════════════════════════════════════════════════════════╗
║ ФОРМАЛНИ ПАРАМЕТРИ                                     ║
╠════════════════════════════════════════════════════════╣
║ - Декларирани в дефиницията на функцията               ║
║ - "Празни кутийки" чакащи стойности                   ║
║ - Пример: int num1, int num2                           ║
╚════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════╗
║ ФАКТИЧЕСКИ ПАРАМЕТРИ                                   ║
╠════════════════════════════════════════════════════════╣
║ - Предадени при извикване на функцията                 ║
║ - Конкретни стойности или променливи                   ║
║ - Пример: a, b или директно 10, 20                     ║
╚════════════════════════════════════════════════════════╝
```

### 📊 Какво се случва при извикване?

```
═══════════════════════════════════════════════════════════
ПРЕДАВАНЕ НА ПАРАМЕТРИ (PASS BY VALUE):
═══════════════════════════════════════════════════════════

main():                    maxOfTwo(num1, num2):
┌──────────┐              ┌──────────┐
│ a = 10   │  ─────────→  │ num1 = 10│  (копие!)
└──────────┘              └──────────┘
                          
┌──────────┐              ┌──────────┐
│ b = 20   │  ─────────→  │ num2 = 20│  (копие!)
└──────────┘              └──────────┘

⚠️ ВАЖНО: Функцията получава КОПИЯ на стойностите!
          Промените вътре във функцията НЕ засягат оригиналите!
═══════════════════════════════════════════════════════════
```

---

<a name="void"></a>
## 📌 void Функции

### 🎯 Какво е void функция?

**void** функция е функция, която **НЕ връща резултат**. 

Вместо това тя:
- ✅ Извършва действие (print, промяна на глобална променлива и т.н.)
- ✅ НЕ използва `return` с стойност
- ✅ Може да използва само `return;` за изход от функцията

### 📝 Пример: void функция

```cpp
#include <iostream>
using namespace std;

// Функция, която ИЗВЕЖДА максимума (не го връща!)
void maxOfTwo(int num1, int num2) {
    if (num1 > num2) {
        cout << num1 << endl;
    } else {
        cout << num2 << endl;
    }
}

int main() {
    int a = 15, b = 25;
    
    cout << "Максимумът е: ";
    maxOfTwo(a, b);  // Извежда директно: 25
    
    return 0;
}
```

### 🔄 Сравнение: return vs void

```cpp
// 1️⃣ Функция с RETURN (връща резултат)
int getMax(int a, int b) {
    if (a > b) return a;
    else return b;
}

// Използване:
int maximum = getMax(10, 20);     // Получаваме резултата
cout << "Max: " << maximum;       // Отпечатваме го

//═══════════════════════════════════════════════════════

// 2️⃣ Функция с VOID (не връща нищо)
void printMax(int a, int b) {
    if (a > b) 
        cout << "Max: " << a << endl;
    else 
        cout << "Max: " << b << endl;
}

// Използване:
printMax(10, 20);                 // Директно отпечатва: Max: 20
// int x = printMax(10, 20);      // ❌ ГРЕШКА! void не връща нищо!
```

**Когато да използваме void:**

```
╔════════════════════════════════════════════════════════╗
║ ИЗПОЛЗВАЙ void КОГАТО:                                 ║
╠════════════════════════════════════════════════════════╣
║ ✅ Функцията извежда резултат (print)                  ║
║ ✅ Функцията променя глобални променливи               ║
║ ✅ Функцията променя параметри по референция           ║
║ ✅ Функцията само изпълнява действие (напр. save)      ║
╚════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════╗
║ ИЗПОЛЗВАЙ return КОГАТО:                               ║
╠════════════════════════════════════════════════════════╣
║ ✅ Нуждаеш се от резултата за по-нататъшни операции   ║
║ ✅ Искаш да съхраниш резултата в променлива            ║
║ ✅ Трябва да върнеш стойност за проверка (bool)        ║
╚════════════════════════════════════════════════════════╝
```

---

<a name="recursion-intro"></a>
## 🔄 ЧАСТ 2: Рекурсия - Въведение

### 🎯 Какво е рекурсия?

**Рекурсия** е когато функция **извиква сама себе си**.

🔑 **Ключови компоненти:**

1. **Базов случай** (Base case) - условие за **спиране**
2. **Рекурсивен случай** (Recursive case) - извикване на **себе си**

### 🌳 Аналогия: Матрьошка кукли

```
     🪆              🪆           🪆         🪆
   Голяма  →      Средна  →    Малка  →  Най-малка
   кукла          кукла        кукла      (БАЗОВ СЛУЧАЙ!)
     │              │            │
     └──────────────┴────────────┘
        Всяка кукла съдържа по-малка
        докато не стигнем най-малката
```

**В рекурсията:**
- Всяка функция "отваря" следващата (извиква себе си)
- Докато не стигнем **базовия случай**
- После се **връщаме назад** и "затваряме" всяка функция

### 📊 Класически пример: Факториел

```cpp
// n! = n × (n-1) × (n-2) × ... × 2 × 1
// 5! = 5 × 4 × 3 × 2 × 1 = 120

int factorial(int n) {
    // БАЗОВ СЛУЧАЙ - спираме рекурсията!
    if (n == 0 || n == 1) {
        return 1;
    }
    
    // РЕКУРСИВЕН СЛУЧАЙ - извикваме себе си!
    return n * factorial(n - 1);
}
```

**Визуализация на изпълнението:**

```
═══════════════════════════════════════════════════════════
factorial(5) - КАК РАБОТИ?
═══════════════════════════════════════════════════════════

Стъпка 1: Извикваме factorial(5)
factorial(5) 
  = 5 * factorial(4)           ← Чака резултат от factorial(4)
      └─→ factorial(4)
            = 4 * factorial(3)  ← Чака резултат от factorial(3)
                └─→ factorial(3)
                      = 3 * factorial(2)  ← Чака factorial(2)
                          └─→ factorial(2)
                                = 2 * factorial(1)  ← Чака factorial(1)
                                    └─→ factorial(1)
                                          = 1  ✓ БАЗОВ СЛУЧАЙ!

───────────────────────────────────────────────────────────

Стъпка 2: Връщаме се назад (UNWINDING):

factorial(1) = 1                    ← Връща 1
              ↓
factorial(2) = 2 * 1 = 2            ← Връща 2
              ↓
factorial(3) = 3 * 2 = 6            ← Връща 6
              ↓
factorial(4) = 4 * 6 = 24           ← Връща 24
              ↓
factorial(5) = 5 * 24 = 120         ← ФИНАЛЕН РЕЗУЛТАТ! ✅

═══════════════════════════════════════════════════════════
```

---

<a name="call-stack"></a>
## 📚 Call Stack (Стек на извикванията)

### 🎯 Какво е Call Stack?

**Call Stack** е структура в паметта, която пази информация за **активните функции**.

**Как работи:**

```
╔════════════════════════════════════════════════════════╗
║ CALL STACK - Работи като стек от чинии                ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  Последна влязла → първа излиза (LIFO)                ║
║                                                        ║
║     ┌─────────────┐                                    ║
║     │ factorial(1)│  ← Последна влязла (TOP)          ║
║     ├─────────────┤                                    ║
║     │ factorial(2)│                                    ║
║     ├─────────────┤                                    ║
║     │ factorial(3)│                                    ║
║     ├─────────────┤                                    ║
║     │ factorial(4)│                                    ║
║     ├─────────────┤                                    ║
║     │ factorial(5)│                                    ║
║     ├─────────────┤                                    ║
║     │   main()    │  ← Първа влязла (BOTTOM)          ║
║     └─────────────┘                                    ║
╚════════════════════════════════════════════════════════╝
```

### 📊 Визуализация на Call Stack при factorial(4)

```
═══════════════════════════════════════════════════════════
CALL STACK - ИЗГРАЖДАНЕ (PUSHING):
═══════════════════════════════════════════════════════════

Извикване: factorial(4)

Стъпка 1:                 Стъпка 2:
┌─────────────┐          ┌─────────────┐
│   main()    │          │factorial(4) │ ← New!
└─────────────┘          ├─────────────┤
                         │   main()    │
                         └─────────────┘

Стъпка 3:                Стъпка 4:
┌─────────────┐          ┌─────────────┐
│factorial(3) │          │factorial(2) │ ← New!
├─────────────┤          ├─────────────┤
│factorial(4) │          │factorial(3) │
├─────────────┤          ├─────────────┤
│   main()    │          │factorial(4) │
└─────────────┘          ├─────────────┤
                         │   main()    │
                         └─────────────┘

Стъпка 5 (БАЗОВ СЛУЧАЙ):
┌─────────────┐
│factorial(1) │ ← Базов случай! return 1
├─────────────┤
│factorial(2) │
├─────────────┤
│factorial(3) │
├─────────────┤
│factorial(4) │
├─────────────┤
│   main()    │
└─────────────┘

───────────────────────────────────────────────────────────
CALL STACK - ВРЪЩАНЕ (POPPING):
───────────────────────────────────────────────────────────

Стъпка 6:                Стъпка 7:
┌─────────────┐          ┌─────────────┐
│factorial(2) │          │factorial(3) │
├─────────────┤          ├─────────────┤
│factorial(3) │          │factorial(4) │
├─────────────┤          ├─────────────┤
│factorial(4) │          │   main()    │
├─────────────┤          └─────────────┘
│   main()    │          return 2 * 1 = 2
└─────────────┘
return 1  ✓

Стъпка 8:                Стъпка 9:
┌─────────────┐          ┌─────────────┐
│factorial(4) │          │   main()    │
├─────────────┤          └─────────────┘
│   main()    │          return 4 * 6 = 24 ✅
└─────────────┘
return 3 * 2 = 6

═══════════════════════════════════════════════════════════
```

### ⚠️ Stack Overflow

Какво става ако **няма базов случай**?

```cpp
// ❌ ГРЕШКА - липсва базов случай!
int badRecursion(int n) {
    return n * badRecursion(n - 1);  // Винаги извиква себе си!
}

// Какво се случва:
badRecursion(5)
  → badRecursion(4)
    → badRecursion(3)
      → badRecursion(2)
        → badRecursion(1)
          → badRecursion(0)
            → badRecursion(-1)
              → badRecursion(-2)
                → ... ∞ БЕЗКРАЙНО!

Резултат: ❌ STACK OVERFLOW ERROR
         (стекът се препълва и програмата се срива!)
```

**Как да избегнем:**

```
✅ ВИНАГИ пиши базов случай ПЪРВИ!
✅ Уверявай се че рекурсията се ПРИБЛИЖАВА към базовия случай!
✅ Тествай с малки числа първо!
```

---

<a name="sum"></a>
## 📌 Задача 105-3: Сума от 1 до n (Рекурсивно)

### 🎯 Условие

Напишете рекурсивна функция за пресмятане на сумата на първите **n** числа:

**s(n) = 1 + 2 + 3 + ... + n**

### 💡 Математическа дефиниция

```
         ┌ 1,              ако n = 1     (БАЗОВ СЛУЧАЙ)
s(n) =   │
         └ s(n-1) + n,     ако n > 1     (РЕКУРСИВЕН СЛУЧАЙ)
```

**Примери:**
- s(1) = 1
- s(2) = s(1) + 2 = 1 + 2 = 3
- s(3) = s(2) + 3 = 3 + 3 = 6
- s(4) = s(3) + 4 = 6 + 4 = 10
- s(5) = s(4) + 5 = 10 + 5 = 15

### 📝 Пълен код на програмата

```cpp
#include <iostream>
using namespace std;

// Функция, която изчислява сумата на числата от 1 до n
int calculateSum(int n) {
    // Базов случай: ако n е 1, връщаме 1
    if (n == 1)
        return 1;
    
    // Рекурсия: добавяме n към резултата от извикването на функцията с n - 1
    else
        return calculateSum(n - 1) + n;
}

int main() {
    int number;  // Декларираме променлива за въвеждане на число
    
    // Подканваме потребителя да въведе число
    cout << "Please enter a positive integer: ";
    cin >> number;  // Въвеждаме числото от потребителя
    
    // Извеждаме резултата от функцията с параметър number
    cout << "The sum of numbers from 1 to " << number 
         << " is: " << calculateSum(number) << endl;
    
    return 0;  // Край на програмата
}
```

### 🔍 Детайлно обяснение на кода

```cpp
int calculateSum(int n) {
    if (n == 1)                      // БАЗОВ СЛУЧАЙ
        return 1;                    // Спираме рекурсията
    else
        return calculateSum(n - 1) + n;  // РЕКУРСИВЕН СЛУЧАЙ
        //     └──────────┬──────────┘
        //       Извикваме себе си с n-1
}
```

**Ключови елементи:**

1. **Базов случай** `if (n == 1)` - Спира рекурсията
2. **Рекурсивно извикване** `calculateSum(n - 1)` - Извикваме себе си
3. **Комбиниране на резултата** `+ n` - Добавяме текущото n

### 📊 Визуализация стъпка по стъпка

#### 🎬 Пример: calculateSum(5)

```
═══════════════════════════════════════════════════════════
ИЗВИКВАНЕ: calculateSum(5)
═══════════════════════════════════════════════════════════

📥 ФАЗА 1: РЕКУРСИВНИ ИЗВИКВАНИЯ (отиваме надолу)
───────────────────────────────────────────────────────────

calculateSum(5)
│ n = 5, n != 1 → продължаваме
│ return calculateSum(4) + 5   ← Чака резултат
│
└──→ calculateSum(4)
     │ n = 4, n != 1 → продължаваме
     │ return calculateSum(3) + 4   ← Чака резултат
     │
     └──→ calculateSum(3)
          │ n = 3, n != 1 → продължаваме
          │ return calculateSum(2) + 3   ← Чака резултат
          │
          └──→ calculateSum(2)
               │ n = 2, n != 1 → продължаваме
               │ return calculateSum(1) + 2   ← Чака резултат
               │
               └──→ calculateSum(1)
                    │ n = 1 → БАЗОВ СЛУЧАЙ! ✓
                    │ return 1  ← Връщаме 1

───────────────────────────────────────────────────────────
📤 ФАЗА 2: ВРЪЩАНЕ НА РЕЗУЛТАТИТЕ (връщаме се нагоре)
───────────────────────────────────────────────────────────

calculateSum(1)
│ return 1                           Резултат: 1
└──────────────────────────────────────────────↓

calculateSum(2) = calculateSum(1) + 2
│ return 1 + 2                       Резултат: 3
└──────────────────────────────────────────────↓

calculateSum(3) = calculateSum(2) + 3
│ return 3 + 3                       Резултат: 6
└──────────────────────────────────────────────↓

calculateSum(4) = calculateSum(3) + 4
│ return 6 + 4                       Резултат: 10
└──────────────────────────────────────────────↓

calculateSum(5) = calculateSum(4) + 5
│ return 10 + 5                      Резултат: 15 ✅

═══════════════════════════════════════════════════════════
ФИНАЛЕН РЕЗУЛТАТ: 15
═══════════════════════════════════════════════════════════
```

### 🎨 Call Stack визуализация

```
═══════════════════════════════════════════════════════════
CALL STACK ПРИ calculateSum(5):
═══════════════════════════════════════════════════════════

Максимална дълбочина на стека:

┌─────────────────────┐
│ calculateSum(1)     │  ← Връща 1
│ n=1, return 1       │
├─────────────────────┤
│ calculateSum(2)     │  ← Чака 1, после връща 1+2=3
│ n=2, чака result    │
├─────────────────────┤
│ calculateSum(3)     │  ← Чака 3, после връща 3+3=6
│ n=3, чака result    │
├─────────────────────┤
│ calculateSum(4)     │  ← Чака 6, после връща 6+4=10
│ n=4, чака result    │
├─────────────────────┤
│ calculateSum(5)     │  ← Чака 10, после връща 10+5=15
│ n=5, чака result    │
├─────────────────────┤
│ main()              │  ← Получава 15
└─────────────────────┘

Дълбочина на стека: 6 нива (main + 5 рекурсивни извиквания)
═══════════════════════════════════════════════════════════
```

### ⏱️ Времева и памета сложност

```
╔════════════════════════════════════════════════════════╗
║ АНАЛИЗ НА СЛОЖНОСТТА                                   ║
╚════════════════════════════════════════════════════════╝

┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Времева сложност    │ O(n)      │ n рекурсивни        │
│                     │           │ извиквания          │
│ Памета сложност     │ O(n)      │ n нива в стека      │
│ Максимална дълбочина│ n         │ При calculateSum(n) │
└─────────────────────┴───────────┴─────────────────────┘

Защо O(n)?
  - Правим ТОЧНО n извиквания на функцията
  - Всяко извикване прави константна работа O(1)
  - Общо: n × O(1) = O(n)

Защо памет O(n)?
  - Call stack съдържа МАКСИМУМ n нива едновременно
  - Всяко ниво заема константна памет
  - Общо: n × O(1) = O(n)
```

### 🔄 Итеративна версия (за сравнение)

```cpp
// Същата функция, но БЕЗ рекурсия
int calculateSumIterative(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}

// Сложност:
// Време: O(n)  - същата като рекурсивната
// Памет: O(1)  - много по-добра! (не използва стек)
```

**Кога да използваме коя:**

```
┌────────────────────────────┬─────────────────────────┐
│ Рекурсивна версия          │ Итеративна версия       │
├────────────────────────────┼─────────────────────────┤
│ ✅ По-елегантен код         │ ✅ По-ефективна памет   │
│ ✅ По-лесно разбираема      │ ✅ По-бърза             │
│ ❌ Използва повече памет    │ ❌ По-сложен код        │
│ ❌ Може да даде Stack       │ ✅ Няма Stack Overflow  │
│    Overflow за голямо n    │                         │
└────────────────────────────┴─────────────────────────┘
```

---

<a name="fibonacci"></a>
## 📌 Задача 105-4: Fibonacci Numbers (Числата на Фибоначи)

### 🎯 Условие

Редицата на Фибоначи се дефинира така:

**0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...**

- Първият елемент е **0**
- Вторият елемент е **1**
- Всеки следващ е **сумата на предходните два**

Напишете рекурсивна функция за пресмятане на **n-тото** число на Фибоначи.

### 💡 Математическа дефиниция

```
           ┌ 0,                      ако n = 1
fib(n) =   │ 1,                      ако n = 2
           └ fib(n-1) + fib(n-2),    ако n > 2
```

**Примери:**
- fib(1) = 0
- fib(2) = 1
- fib(3) = fib(2) + fib(1) = 1 + 0 = 1
- fib(4) = fib(3) + fib(2) = 1 + 1 = 2
- fib(5) = fib(4) + fib(3) = 2 + 1 = 3
- fib(6) = fib(5) + fib(4) = 3 + 2 = 5

### 📝 Пълен код на програмата

```cpp
#include <iostream>
using namespace std;

// Функция за изчисляване на n-тото число от редицата на Фибоначи
int fibonacci(int n) {
    // Ако n е 1, връщаме 0 (първото число от редицата)
    if (n == 1)
        return 0;
    
    // Ако n е 2, връщаме 1 (второто число от редицата)
    if (n == 2)
        return 1;
    
    // В останалите случаи връщаме сумата на предишните две числа
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;
    
    // Промпт за въвеждане на n от потребителя
    cout << "Please enter the position of the Fibonacci sequence: ";
    cin >> n;  // Въвеждаме числото от потребителя
    
    // Извеждаме n-тото число от редицата на Фибоначи
    cout << "The " << n << "-th Fibonacci number is: " 
         << fibonacci(n) << endl;
    
    return 0;  // Край на програмата
}
```

### 🔍 Детайлно обяснение на кода

```cpp
int fibonacci(int n) {
    // ДВА базови случая!
    if (n == 1) return 0;    // БАЗОВ СЛУЧАЙ 1
    if (n == 2) return 1;    // БАЗОВ СЛУЧАЙ 2
    
    // РЕКУРСИВЕН СЛУЧАЙ - извикваме себе си ДВА ПЪТИ!
    return fibonacci(n - 1) + fibonacci(n - 2);
    //     └──────┬──────┘   └──────┬──────┘
    //        предишно          пред-предишно
}
```

**Ключова разлика с предишните задачи:**

```
╔════════════════════════════════════════════════════════╗
║ calculateSum(n):                                       ║
║   → Прави ЕДНО рекурсивно извикване                   ║
║   → Линейна рекурсия                                   ║
╠════════════════════════════════════════════════════════╣
║ fibonacci(n):                                          ║
║   → Прави ДВЕ рекурсивни извиквания                   ║
║   → Дървовидна рекурсия                                ║
╚════════════════════════════════════════════════════════╝
```

### 📊 Визуализация стъпка по стъпка

#### 🎬 Пример: fibonacci(6)

```
═══════════════════════════════════════════════════════════
ИЗВИКВАНЕ: fibonacci(6)
═══════════════════════════════════════════════════════════

                        fib(6)
                          │
         ┌────────────────┴────────────────┐
         │                                  │
       fib(5)                            fib(4)
         │                                  │
    ┌────┴────┐                        ┌────┴────┐
    │         │                        │         │
  fib(4)   fib(3)                   fib(3)   fib(2)
    │         │                        │         │
 ┌──┴──┐   ┌─┴─┐                    ┌─┴─┐       1
 │     │   │   │                    │   │
fib(3) fib(2) fib(2) fib(1)    fib(2) fib(1)
 │     │   1     0               1     0
┌┴┐    1
│ │
fib(2) fib(1)
1      0

───────────────────────────────────────────────────────────
ОБЯСНЕНИЕ:
───────────────────────────────────────────────────────────

1. fib(6) се разклонява на fib(5) и fib(4)
2. fib(5) се разклонява на fib(4) и fib(3)
3. ... и така нататък докато не стигнем fib(1) или fib(2)

⚠️ ВАЖНО: Забележи че fib(4), fib(3), fib(2) се изчисляват
          МНОГОКРАТНО! Това е неефективно!

═══════════════════════════════════════════════════════════
```

### 📈 Детайлни стъпки с изчисления

```
═══════════════════════════════════════════════════════════
ИЗЧИСЛЕНИЕ НА fibonacci(6):
═══════════════════════════════════════════════════════════

Ниво 1:
  fib(6) = fib(5) + fib(4)

Ниво 2:
  fib(5) = fib(4) + fib(3)
  fib(4) = fib(3) + fib(2)

Ниво 3:
  fib(4) = fib(3) + fib(2)
  fib(3) = fib(2) + fib(1)
  fib(3) = fib(2) + fib(1)
  fib(2) = 1 ✓

Ниво 4 (базови случаи):
  fib(3) = fib(2) + fib(1) = 1 + 0 = 1
  fib(2) = 1 ✓
  fib(2) = 1 ✓
  fib(1) = 0 ✓
  fib(2) = 1 ✓
  fib(1) = 0 ✓

───────────────────────────────────────────────────────────
ВРЪЩАНЕ НАЗАД:
───────────────────────────────────────────────────────────

fib(3) = 1 + 0 = 1
fib(4) = 1 + 1 = 2
fib(3) = 1 + 0 = 1
fib(5) = 2 + 1 = 3
fib(4) = 1 + 1 = 2
fib(6) = 3 + 2 = 5 ✅

ФИНАЛЕН РЕЗУЛТАТ: 5
═══════════════════════════════════════════════════════════
```

### 🔢 Таблица на извикванията

```
═══════════════════════════════════════════════════════════
КОЛКО ПЪТИ СЕ ИЗВИКВА ВСЯКА ФУНКЦИЯ?
═══════════════════════════════════════════════════════════

┌──────────┬───────────────┬─────────────────────────────┐
│ Функция  │ Брой пъти     │ Визуализация                │
├──────────┼───────────────┼─────────────────────────────┤
│ fib(6)   │ 1             │ ●                           │
│ fib(5)   │ 1             │ ●                           │
│ fib(4)   │ 2             │ ● ●                         │
│ fib(3)   │ 3             │ ● ● ●                       │
│ fib(2)   │ 5             │ ● ● ● ● ●                   │
│ fib(1)   │ 3             │ ● ● ●                       │
├──────────┼───────────────┼─────────────────────────────┤
│ ОБЩО:    │ 15 извиквания │                             │
└──────────┴───────────────┴─────────────────────────────┘

⚠️ ПРОБЛЕМ: fib(4) се изчислява 2 пъти
            fib(3) се изчислява 3 пъти
            fib(2) се изчислява 5 пъти!
            
Това е МНОГО НЕЕФЕКТИВНО! 💸
═══════════════════════════════════════════════════════════
```

### ⏱️ Времева и памета сложност

```
╔════════════════════════════════════════════════════════╗
║ АНАЛИЗ НА СЛОЖНОСТТА                                   ║
╚════════════════════════════════════════════════════════╝

┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Времева сложност    │ O(2^n)    │ ЕКСПОНЕНЦИАЛНА! ⚠️  │
│                     │           │ МНОГО БАВНА!        │
│ Памета сложност     │ O(n)      │ Максимална дълбочина│
│                     │           │ на стека            │
│ Брой извиквания     │ ≈ 2^n     │ Расте експоненциално│
└─────────────────────┴───────────┴─────────────────────┘

Защо O(2^n)?
  - Всяко извикване прави 2 нови извиквания
  - Дървото има височина n
  - Общ брой възли ≈ 2^n

Примери:
  fib(10) → ~1000 извиквания
  fib(20) → ~1,000,000 извиквания
  fib(30) → ~1,000,000,000 извиквания (1 секунда!)
  fib(40) → ~1,000,000,000,000 извиквания (много минути!)
```

### 📊 Растеж на броя извиквания

```
╔════════════════════════════════════════════════════════╗
║ РАСТЕЖ НА СЛОЖНОСТТА                                   ║
╚════════════════════════════════════════════════════════╝

n    │ Брой извиквания │ Приблизително време
─────┼──────────────────┼────────────────────────────
1    │ 1                │ < 1 μs
2    │ 3                │ < 1 μs
3    │ 5                │ < 1 μs
4    │ 9                │ < 1 μs
5    │ 15               │ < 1 μs
6    │ 25               │ < 1 μs
10   │ 177              │ < 1 μs
15   │ 1,973            │ < 1 μs
20   │ 21,891           │ ≈ 10 μs
25   │ 242,785          │ ≈ 100 μs
30   │ 2,692,537        │ ≈ 1 ms
35   │ 29,860,703       │ ≈ 10 ms
40   │ 331,160,281      │ ≈ 150 ms
45   │ 3,672,623,805    │ ≈ 1.5 сек
50   │ 40,730,022,147   │ ≈ 18 сек ⚠️

⚠️ За n > 50 → НЕПРАКТИЧНО бавно!
```

### 🚀 Оптимизация: Мемоизация (Memoization)

За да направим Fibonacci ефективна, използваме **мемоизация** - запазваме вече изчислените стойности:

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

// Глобален кеш за съхранение на резултатите
unordered_map<int, int> memo;

int fibonacciMemo(int n) {
    // Базови случаи
    if (n == 1) return 0;
    if (n == 2) return 1;
    
    // Проверяваме дали сме го изчислявали вече
    if (memo.find(n) != memo.end()) {
        return memo[n];  // Връщаме запазения резултат
    }
    
    // Изчисляваме и запазваме резултата
    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
    return memo[n];
}

// Сложност:
// Време: O(n)  - всяко число се изчислява ВЕДНЪЖ!
// Памет: O(n)  - за кеша + стека
```

**Сравнение:**

```
┌─────────────────────┬─────────────┬─────────────────┐
│ Версия              │ Време       │ Извиквания      │
├─────────────────────┼─────────────┼─────────────────┤
│ Обикновена рекурсия │ O(2^n)      │ ~2^n            │
│ С мемоизация        │ O(n)        │ ~2n             │
│ Итеративна          │ O(n)        │ 0 (без рекурсия)│
└─────────────────────┴─────────────┴─────────────────┘

За fib(40):
  Обикновена: ~330,000,000 извиквания, ~150 ms
  Мемоизация: ~80 извиквания, < 1 ms  ← 150,000× ПО-БЪРЗО!
```

### 💡 Итеративна версия (най-ефективна)

```cpp
int fibonacciIterative(int n) {
    if (n == 1) return 0;
    if (n == 2) return 1;
    
    int prev2 = 0;  // fib(n-2)
    int prev1 = 1;  // fib(n-1)
    int current;
    
    for (int i = 3; i <= n; i++) {
        current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    
    return current;
}

// Сложност:
// Време: O(n)
// Памет: O(1)  ← НАЙ-ДОБРА!
```

---

<a name="quicksort"></a>
## 📌 Задача 105-5: QuickSort (Бързо сортиране - рекурсивно)

### 🎯 Какво е QuickSort?

**QuickSort** е един от най-бързите алгоритми за сортиране, използващ **рекурсия** и **"разделяй и владей"** (divide and conquer).

**Основна идея:**

1. Избираме **pivot** (опорен елемент)
2. **Разделяме** масива: малките вляво, големите вдясно от pivot
3. **Рекурсивно** сортираме лявата и дясната част

### 📝 Пълен код на програмата

```cpp
#include <iostream>
using namespace std;

int arr[50]; // Глобален масив

// Функция за quicksort алгоритъм
void quicksort(int left, int right) {
    // Избираме средния елемент като "pivot"
    int pivot = arr[(left + right) / 2];
    int i = left, j = right;
    int tempVar; // Временна променлива за размяна на елементи
    
    // Основният цикъл за сортиране
    while (i <= j) {
        // Намиране на елементи, които са на грешна позиция спрямо pivot
        while (arr[i] < pivot) i++;
        while (arr[j] > pivot) j--;
        
        // Размяна на елементи и преместване на индексите
        if (i <= j) {
            tempVar = arr[i];
            arr[i] = arr[j];
            arr[j] = tempVar;
            i++;
            j--;
        }
    }
    
    // Рекурсивно сортиране на подмасивите
    if (left < j) quicksort(left, j);
    if (i < right) quicksort(i, right);
}

int main() {
    int n, i;
    
    // Подканваме потребителя да въведе брой на елементите
    cout << "Enter the number of elements: ";
    cin >> n;
    
    // Подканваме потребителя да въведе елементите
    cout << "Enter the elements: ";
    for (i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    // Извикваме quicksort за сортиране на масива
    quicksort(0, n - 1);
    
    // Извеждаме сортирания масив
    cout << "Sorted elements:" << endl;
    for (i = 0; i < n; i++) {
        cout << arr[i] << endl;
    }
    
    return 0;
}
```

### 🔍 Как работи QuickSort?

#### Стъпка 1: Partitioning (Разделяне)

```
═══════════════════════════════════════════════════════════
ПРИМЕР: Сортиране на [8, 3, 6, 2, 10, 5, 1]
═══════════════════════════════════════════════════════════

Начален масив:
[8, 3, 6, 2, 10, 5, 1]
          ↑
       pivot = 2 (средният елемент)

Цел: Преместваме всички < 2 вляво, всички > 2 вдясно

Стъпка по стъпка:
  
i = 0, j = 6
[8, 3, 6, 2, 10, 5, 1]
 ↑                 ↑
 i                 j

arr[i]=8 >= pivot=2, arr[j]=1 < pivot=2 → РАЗМЯНА!
[1, 3, 6, 2, 10, 5, 8]
 ↑                 ↑
i++, j--

i = 1, j = 5
[1, 3, 6, 2, 10, 5, 8]
    ↑          ↑
    i          j

arr[i]=3 >= pivot=2, arr[j]=5 >= pivot=2
i остава, j--

i = 1, j = 4
[1, 3, 6, 2, 10, 5, 8]
    ↑       ↑
    i       j

... продължава докато i > j

РЕЗУЛТАТ СЛЕД PARTITIONING:
[1, 2 | 3, 6, 10, 5, 8]
      ↑
   pivot е на място!
   
Малките (< 2) са вляво: [1, 2]
Големите (> 2) са вдясно: [3, 6, 10, 5, 8]

───────────────────────────────────────────────────────────
```

#### Стъпка 2: Рекурсивно сортиране

```
═══════════════════════════════════════════════════════════
ДЪРВО НА РЕКУРСИЯТА:
═══════════════════════════════════════════════════════════

                [8,3,6,2,10,5,1]
                     pivot=2
                        │
           ┌────────────┴────────────┐
           │                         │
       [1, 2]                [3,6,10,5,8]
      pivot=2                   pivot=6
     НА МЯСТО!                     │
                          ┌────────┴────────┐
                          │                 │
                      [3, 5]           [10, 8]
                     pivot=5           pivot=10
                   НА МЯСТО!           НА МЯСТО!
                          │                 │
                   ┌──────┴──────┐          │
                   │             │          │
                 [3]           [5]        [8]
              НА МЯСТО!    НА МЯСТО!  НА МЯСТО!

ФИНАЛЕН РЕЗУЛТАТ: [1, 2, 3, 5, 6, 8, 10] ✅
═══════════════════════════════════════════════════════════
```

### ⏱️ Времева и памета сложност

```
╔════════════════════════════════════════════════════════╗
║ АНАЛИЗ НА СЛОЖНОСТТА                                   ║
╚════════════════════════════════════════════════════════╝

┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Най-добър случай    │ O(n log n)│ Балансирано делене  │
│ Среден случай       │ O(n log n)│ Типичен случай      │
│ Най-лош случай      │ O(n²)     │ Вече сортиран ⚠️    │
│ Памета сложност     │ O(log n)  │ Рекурсивен стек     │
└─────────────────────┴───────────┴─────────────────────┘

Защо O(n log n) в среден случай?
  - Дълбочина на рекурсията: log n
  - Работа на всяко ниво: n (partitioning)
  - Общо: n × log n

Защо O(n²) в най-лош случай?
  - Когато винаги избираме най-лошия pivot
  - Например: масив [1, 2, 3, 4, 5]
  - Pivot винаги е най-малкият/най-големият
  - Дълбочина на рекурсията: n
  - Общо: n × n = n²
```

### 📊 Сравнение с други сортировки

```
┌───────────────┬────────────┬────────────┬──────────┐
│ Алгоритъм     │ Среден     │ Най-лош    │ Памет    │
├───────────────┼────────────┼────────────┼──────────┤
│ Bubble Sort   │ O(n²)      │ O(n²)      │ O(1)     │
│ Insertion     │ O(n²)      │ O(n²)      │ O(1)     │
│ Quick Sort    │ O(n log n) │ O(n²) ⚠️   │ O(log n) │
│ Merge Sort    │ O(n log n) │ O(n log n) │ O(n)     │
│ Heap Sort     │ O(n log n) │ O(n log n) │ O(1)     │
└───────────────┴────────────┴────────────┴──────────┘

⚡ QuickSort е НАЙ-БЪРЗ на практика въпреки O(n²) worst case!
```

---

<a name="complexity"></a>
## 📊 Анализ на сложността на рекурсивните алгоритми

### 🎯 Как да анализираме рекурсивна функция?

**Стъпки:**

1. Намери броя на рекурсивните извиквания
2. Намери работата на всяко извикване
3. Намери дълбочината на рекурсията
4. Изчисли обща сложност

### 📊 Примери

```
╔════════════════════════════════════════════════════════╗
║ СРАВНЕНИЕ НА РЕКУРСИВНИ АЛГОРИТМИ                      ║
╚════════════════════════════════════════════════════════╝

┌──────────────────┬─────────────┬───────────┬──────────┐
│ Функция          │ Рекурсивни  │ Дълбочина │ Време    │
│                  │ извиквания  │ на стека  │          │
├──────────────────┼─────────────┼───────────┼──────────┤
│ factorial(n)     │ 1 на стъпка │ n         │ O(n)     │
│ calculateSum(n)  │ 1 на стъпка │ n         │ O(n)     │
│ fibonacci(n)     │ 2 на стъпка │ n         │ O(2^n) ⚠️│
│ quickSort(n)     │ 2 на стъпка │ log n*    │ O(nlogn) │
│ mergeSort(n)     │ 2 на стъпка │ log n     │ O(nlogn) │
└──────────────────┴─────────────┴───────────┴──────────┘

* в среден случай
```

### 🔍 Детайлен анализ

#### 1. Линейна рекурсия (1 извикване)

```cpp
int sum(int n) {
    if (n == 1) return 1;
    return sum(n-1) + n;
}

Брой извиквания: n
Работа на извикване: O(1)
Дълбочина: n
→ ВРЕМЕ: O(n), ПАМЕТ: O(n)
```

#### 2. Дървовидна рекурсия (2 извиквания)

```cpp
int fib(int n) {
    if (n <= 2) return 1;
    return fib(n-1) + fib(n-2);
}

Брой извиквания: ≈ 2^n
Работа на извикване: O(1)
Дълбочина: n
→ ВРЕМЕ: O(2^n), ПАМЕТ: O(n)
```

#### 3. Divide and Conquer

```cpp
void quickSort(int left, int right) {
    // ... partitioning: O(n)
    quickSort(left, mid);
    quickSort(mid+1, right);
}

Брой извиквания: O(n) в общия случай
Работа на извикване: O(n/2^level)
Дълбочина: log n
→ ВРЕМЕ: O(n log n), ПАМЕТ: O(log n)
```

---

<a name="recursion-vs-iteration"></a>
## 🔄 Рекурсия vs Итерация

### 🎯 Кога да използваме коя?

```
╔════════════════════════════════════════════════════════╗
║ ИЗПОЛЗВАЙ РЕКУРСИЯ КОГАТО:                             ║
╠════════════════════════════════════════════════════════╣
║ ✅ Проблемът естествено се разделя на подпроблеми      ║
║ ✅ Кодът става много по-четим                          ║
║ ✅ Работиш с дървовидни структури                      ║
║ ✅ Алгоритъмът е "divide and conquer"                  ║
║                                                        ║
║ Примери: QuickSort, MergeSort, обхождане на дървета   ║
╚════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════╗
║ ИЗПОЛЗВАЙ ИТЕРАЦИЯ КОГАТО:                             ║
╠════════════════════════════════════════════════════════╣
║ ✅ Паметта е ограничена                                ║
║ ✅ Нуждаеш се от максимална ефективност                ║
║ ✅ Проблемът е прост и последователен                  ║
║ ✅ n може да е много голямо (риск от Stack Overflow)   ║
║                                                        ║
║ Примери: Fibonacci, сума, факториел                    ║
╚════════════════════════════════════════════════════════╝
```

### 📊 Сравнителна таблица

```
┌──────────────────────┬─────────────┬─────────────────┐
│ Характеристика       │ Рекурсия    │ Итерация        │
├──────────────────────┼─────────────┼─────────────────┤
│ Четимост на кода     │ ⭐⭐⭐⭐⭐     │ ⭐⭐⭐           │
│ Ефективност (време)  │ ⭐⭐⭐        │ ⭐⭐⭐⭐⭐        │
│ Използвана памет     │ ⭐⭐         │ ⭐⭐⭐⭐⭐        │
│ Риск от Stack        │ ⚠️ ДА       │ ✅ НЕ           │
│ Overflow             │             │                 │
│ Подходяща за дървета │ ⭐⭐⭐⭐⭐     │ ⭐⭐             │
│ Лесна за дебъгване   │ ⭐⭐⭐        │ ⭐⭐⭐⭐          │
└──────────────────────┴─────────────┴─────────────────┘
```

---

<a name="common-mistakes"></a>
## ⚠️ Често срещани грешки при рекурсия

### 1️⃣ Липсващ базов случай

```cpp
// ❌ ГРЕШКА!
int bad(int n) {
    return n + bad(n - 1);  // Няма базов случай!
}

// ✅ ПРАВИЛНО
int good(int n) {
    if (n == 0) return 0;   // Базов случай!
    return n + good(n - 1);
}
```

### 2️⃣ Грешно условие за спиране

```cpp
// ❌ ГРЕШКА - никога не спира за отрицателни числа!
int bad(int n) {
    if (n == 0) return 0;
    return n + bad(n - 1);
}

// ✅ ПРАВИЛНО
int good(int n) {
    if (n <= 0) return 0;   // <= вместо ==
    return n + good(n - 1);
}
```

### 3️⃣ Забравяне на return

```cpp
// ❌ ГРЕШКА!
int bad(int n) {
    if (n == 1) return 1;
    bad(n - 1) + n;  // Липсва return!
}

// ✅ ПРАВИЛНО
int good(int n) {
    if (n == 1) return 1;
    return good(n - 1) + n;  // return!
}
```

### 4️⃣ Безкрайна рекурсия

```cpp
// ❌ ГРЕШКА!
int bad(int n) {
    if (n == 0) return 0;
    return bad(n + 1);  // n расте вместо да намалява!
}

// ✅ ПРАВИЛНО
int good(int n) {
    if (n == 0) return 0;
    return good(n - 1);  // n намалява към базовия случай
}
```

---

## 🎓 Заключение

### 🌟 Ключови изводи

```
╔════════════════════════════════════════════════════════╗
║ ЩО НАУЧИХМЕ?                                           ║
╚════════════════════════════════════════════════════════╝

✅ ФУНКЦИИ:
   - Как да дефинираме и използваме функции
   - return vs void функции
   - Параметри и извиквания

✅ РЕКУРСИЯ:
   - Функция която извиква сама себе си
   - Базов случай + рекурсивен случай
   - Call Stack и как работи

✅ ПРИМЕРИ:
   - calculateSum - O(n)
   - fibonacci - O(2^n) - неефективна!
   - quickSort - O(n log n) - ефективна!

✅ АНАЛИЗ:
   - Времева сложност
   - Памета сложност
   - Кога е по-добре итерация
```

### 💡 Практически съвети

1. **Винаги пиши базовия случай ПЪРВИ!**
2. **Тествай с малки стойности** (n=1, n=2, n=3)
3. **Рисувай дървото на рекурсията** за да разбереш потока
4. **Използвай мемоизация** за оптимизация
5. **Внимавай за Stack Overflow** при големи n

### 🚀 Следващи стъпки

След като овладееш рекурсията:

1. **Динамично програмиране** - оптимизация на рекурсия
2. **Backtracking** - търсене с връщане назад
3. **Дървета и графи** - рекурсивни структури
4. **Divide and Conquer** - по-сложни алгоритми

---

**🎉 Благодаря че прочете това ръководство!**

Надявам се че сега разбираш НАПЪЛНО как работи рекурсията! 🔄

**Успех с програмирането!** 💪

---

*Създадено за студенти, които искат да разберат рекурсията отблизо!*

