# МЕТОДИЧЕСКО ОПИСАНИЕ
## Реализация на хеш-таблица с управление на колизии чрез свързани списъци

---

## 1. ЦЕЛИ И ЗАДАЧИ НА ПРОГРАМАТА

Програмата демонстрира реализацията на асоциативна структура от данни - хеш-таблица, която осигурява бърз достъп до елементите чрез уникален целочислен ключ. 

**Основни цели:**
- Илюстриране на концепцията за хеширане и хеш-функции
- Демонстрация на метода за управление на колизии чрез свързани списъци
- Реализация на основните операции: вмъкване, търсене и извличане на елементи
- Показване на практическо приложение на динамично разпределени структури от данни

---

## 2. ТЕОРЕТИЧНА ОСНОВА

### 2.1. Понятие за хеш-таблица

Хеш-таблицата е структура от данни, която съхранява двойки ключ-стойност и позволява:
- Бързо вмъкване на елементи: O(1) средна сложност
- Бързо търсене по ключ: O(1) средна сложност
- Ефективно използване на паметта при подходящ избор на размер

### 2.2. Хеш-функция

Хеш-функцията преобразува ключа в индекс на масива:
```
h(key) = key mod n
```
където n = 211 е размерът на хеш-таблицата (просто число за по-добро разпределение).

### 2.3. Колизии

Колизия възниква, когато два различни ключа се изобразяват в един и същ индекс. В настоящата реализация колизиите се разрешават чрез метода на свързване (chaining) - всяка позиция в масива съдържа указател към свързан списък.

---

## 3. СТРУКТУРА НА ПРОГРАМАТА

### 3.1. Глобални константи и променливи

```cpp
const int n = 211;
```
**Размер на хеш-таблицата:** Избрано е простото число 211, което осигурява добро разпределение на елементите и намалява вероятността от колизии.

```cpp
list* hashTable[n];
```
**Хеш-таблицата:** Масив от указатели към свързани списъци. Всеки елемент от масива е началото на верига от елементи, които имат хеш-стойност, равна на индекса.

### 3.2. Структура за свързан списък

```cpp
struct list {
    int key;        // ключ на елемента
    int i;          // стойност на елемента
    list* next;     // указател към следващия елемент
};
```

**Описание на полетата:**
- `key` - уникален идентификатор на елемента
- `i` - съхранената стойност
- `next` - връзка към следващия елемент при колизия

---

## 4. ФУНКЦИОНАЛНИ КОМПОНЕНТИ

### 4.1. Инициализация на хеш-таблицата

```cpp
void initHashTable()
```

**Предназначение:** Подготвя хеш-таблицата за работа, като задава начални стойности NULL на всички указатели в масива.

**Алгоритъм:**
1. Обхождане на всички n позиции в масива
2. Присвояване на стойност NULL, което означава празен свързан списък

**Времева сложност:** O(n)

---

### 4.2. Хеш-функция

```cpp
int hashFunction(int key)
```

**Предназначение:** Изчислява индекса в масива за даден ключ.

**Математическа формула:**
```
индекс = ключ mod 211
```

**Свойства:**
- Детерминирана: един и същ ключ винаги дава един и същ индекс
- Равномерно разпределение: използването на просто число n подобрява разпределението
- Бързо изчисление: операцията деление с остатък е ефективна

**Времева сложност:** O(1)

**Пример:**
- key = 1234 → hashFunction(1234) = 1234 % 211 = 179
- key = 1774 → hashFunction(1774) = 1774 % 211 = 86
- key = 86 → hashFunction(86) = 86 % 211 = 86

---

### 4.3. Вмъкване в началото на списък

```cpp
void insertBegin(list* &l, int k, int x)
```

**Предназначение:** Добавя нов елемент в началото на свързания списък.

**Параметри:**
- `l` - референция към указател към началото на списъка
- `k` - ключ на новия елемент
- `x` - стойност на новия елемент

**Алгоритъм:**
1. Динамично заделяне на памет за нов елемент
2. Присвояване на ключ и стойност
3. Свързване на новия елемент с предишното начало
4. Актуализиране на началото на списъка

**Времева сложност:** O(1)

**Защо в началото?**
- Най-бързата операция - няма нужда от обхождане
- Последно добавените елементи често се търсят първи (принцип на локалност)

---

### 4.4. Търсене в свързан списък

```cpp
list* search(list* l, int k)
```

**Предназначение:** Намира елемент с даден ключ в свързания списък.

**Параметри:**
- `l` - указател към началото на списъка
- `k` - търсен ключ

**Връщана стойност:**
- Указател към намерения елемент
- NULL, ако елементът не е намерен

**Алгоритъм:**
1. Последователно обхождане на списъка
2. Сравняване на всеки ключ с търсения
3. Връщане при намиране или достигане на края

**Времева сложност:** O(m), където m е дължината на списъка в дадената позиция

---

### 4.5. Изтриване на елемент

```cpp
void deletel(list* &l, int k)
```

**Предназначение:** Премахва елемент с даден ключ от свързания списък.

**Параметри:**
- `l` - референция към указател към началото на списъка
- `k` - ключ на елемента за изтриване

**Алгоритъм:**

**Случай 1: Първият елемент съвпада с ключа**
1. Запазване на указателя към първия елемент
2. Преместване на началото към втория елемент
3. Освобождаване на паметта на премахнатия елемент

**Случай 2: Елементът е в средата или края на списъка**
1. Обхождане до намиране на елемента преди търсения
2. Препращане на указателя за прескачане на търсения елемент
3. Освобождаване на паметта

**Времева сложност:** O(m)

**Важно:** Функцията не проверява дали ключът съществува - предполага се, че извикващият код е проверил това предварително.

---

### 4.6. Вмъкване в хеш-таблицата

```cpp
void put(int key, int x)
```

**Предназначение:** Добавя нова двойка ключ-стойност в хеш-таблицата.

**Параметри:**
- `key` - ключ на новия елемент
- `x` - стойност на новия елемент

**Алгоритъм:**
1. Изчисляване на индекса чрез хеш-функцията
2. Вмъкване на елемента в началото на списъка на съответния индекс

**Времева сложност:** O(1) средно

**Особености:**
- Не проверява за дублиращи се ключове
- При колизия просто добавя в списъка
- Може да води до множество елементи с един ключ (ако се извика многократно)

---

### 4.7. Извличане от хеш-таблицата

```cpp
int get(int key)
```

**Предназначение:** Извлича стойността, свързана с даден ключ.

**Параметри:**
- `key` - ключ на търсения елемент

**Връщана стойност:**
- Стойността на елемента, ако е намерен
- -1, ако ключът не съществува в таблицата

**Алгоритъм:**
1. Изчисляване на индекса чрез хеш-функцията
2. Търсене на елемента в списъка на този индекс
3. Връщане на стойността или -1

**Времева сложност:** O(1) средно, O(m) най-лош случай

---

## 5. АНАЛИЗ НА ГЛАВНАТА ФУНКЦИЯ

### 5.1. Последователност на изпълнение

```cpp
int main() {
    initHashTable();
    
    put(1234, 100);
    put(1774, 120);
    put(86, 180);
    
    cout << get(86) << endl;
    cout << get(1234) << endl;
    cout << get(1774) << endl;
    cout << get(1773) << endl;
    
    return 0;
}
```

### 5.2. Детайлно проследяване

**Стъпка 1: Инициализация**
```
hashTable[0] = NULL
hashTable[1] = NULL
...
hashTable[210] = NULL
```

**Стъпка 2: Вмъкване на (1234, 100)**
- hashFunction(1234) = 179
- hashTable[179] → [key:1234, i:100, next:NULL]

**Стъпка 3: Вмъкване на (1774, 120)**
- hashFunction(1774) = 86
- hashTable[86] → [key:1774, i:120, next:NULL]

**Стъпка 4: Вмъкване на (86, 180) - КОЛИЗИЯ!**
- hashFunction(86) = 86
- hashTable[86] → [key:86, i:180, next:→] → [key:1774, i:120, next:NULL]

**Визуално представяне на колизията:**
```
hashTable[86]:
  ┌─────────────┐    ┌──────────────┐
  │ key: 86     │───→│ key: 1774    │───→ NULL
  │ i: 180      │    │ i: 120       │
  └─────────────┘    └──────────────┘
```

**Стъпка 5-8: Извличане на стойности**
- get(86) → търси в hashTable[86] → намира първия елемент → връща 180
- get(1234) → търси в hashTable[179] → намира елемента → връща 100
- get(1774) → търси в hashTable[86] → намира втория елемент → връща 120
- get(1773) → търси в hashTable[86] → не намира → връща -1

**Изход на програмата:**
```
180
100
120
-1
```

---

## 6. АНАЛИЗ НА СЛОЖНОСТТА

### 6.1. Пространствена сложност

**Хеш-таблица:** O(n) = O(211) за масива от указатели

**Елементи:** O(k), където k е броят на вмъкнатите елементи

**Обща:** O(n + k)

### 6.2. Времева сложност на операциите

| Операция | Среден случай | Най-лош случай |
|----------|---------------|----------------|
| Вмъкване (put) | O(1) | O(1) |
| Търсене (get) | O(1) | O(k/n) |
| Изтриване (deletel) | O(1) | O(k/n) |
| Инициализация | O(n) | O(n) |

**Забележка:** При добър избор на хеш-функция и подходящ размер на таблицата, средният брой елементи в списък е много малък (≈1-2), което води до почти константно време за операциите.

---

## 7. ПРЕДИМСТВА И НЕДОСТАТЪЦИ НА РЕАЛИЗАЦИЯТА

### 7.1. Предимства

**Простота:**
- Лесна за разбиране и реализация
- Минимален код за основните операции

**Ефективност:**
- Бързи операции при добро разпределение
- Динамично използване на паметта

**Гъвкавост:**
- Няма ограничение на броя елементи (освен наличната памет)
- Лесно управление на колизиите

### 7.2. Недостатъци

**Липса на проверки:**
- Не се проверява за дублиращи се ключове
- Не се обработват грешки (например get() на празна таблица)

**Фиксиран размер:**
- Размерът n е константа и не може да се променя динамично
- При много елементи списъците стават дълги

**Ограничения:**
- Работи само с целочислени ключове
- Връща -1 при липса на елемент (проблем, ако -1 е валидна стойност)

**Управление на паметта:**
- Липсва деструктор за освобождаване на паметта
- Възможна е теч на памет при многократно използване

---

## 8. ВЪЗМОЖНИ ПОДОБРЕНИЯ

### 8.1. Добавяне на проверки

```cpp
void put(int key, int x) {
    int place = hashFunction(key);
    
    // Проверка за съществуващ ключ
    list* existing = search(hashTable[place], key);
    if (existing != NULL) {
        existing->i = x;  // Актуализиране вместо дублиране
        return;
    }
    
    insertBegin(hashTable[place], key, x);
}
```

### 8.2. Подобрено извличане

```cpp
bool get(int key, int& value) {
    int place = hashFunction(key);
    list* l = search(hashTable[place], key);
    
    if (l != NULL) {
        value = l->i;
        return true;
    }
    return false;
}
```

### 8.3. Деструктор за освобождаване на паметта

```cpp
void clearHashTable() {
    for (int i = 0; i < n; i++) {
        list* current = hashTable[i];
        while (current != NULL) {
            list* temp = current;
            current = current->next;
            delete temp;
        }
        hashTable[i] = NULL;
    }
}
```

### 8.4. Статистика и анализ

```cpp
void printStatistics() {
    int emptySlots = 0;
    int maxChainLength = 0;
    int totalElements = 0;
    
    for (int i = 0; i < n; i++) {
        if (hashTable[i] == NULL) {
            emptySlots++;
        } else {
            int chainLength = 0;
            list* current = hashTable[i];
            while (current != NULL) {
                chainLength++;
                totalElements++;
                current = current->next;
            }
            if (chainLength > maxChainLength) {
                maxChainLength = chainLength;
            }
        }
    }
    
    cout << "Общо елементи: " << totalElements << endl;
    cout << "Празни позиции: " << emptySlots << endl;
    cout << "Фактор на запълване: " << (double)totalElements / n << endl;
    cout << "Максимална дължина на верига: " << maxChainLength << endl;
}
```

---

## 9. ПРАКТИЧЕСКИ СЪВЕТИ ЗА СТУДЕНТИТЕ

### 9.1. При изучаване на кода

1. **Проследете стъпка по стъпка:**
   - Начертайте хеш-таблицата на хартия
   - Визуализирайте свързаните списъци
   - Отбележете указателите и връзките

2. **Експериментирайте:**
   - Променете размера на таблицата
   - Добавете повече елементи
   - Създайте намерени колизии

3. **Задайте си въпроси:**
   - Какво става при търсене на несъществуващ ключ?
   - Как се променя структурата при многократно вмъкване?
   - Кога и защо възникват колизии?

### 9.2. При разширяване на програмата

1. **Добавете нови операции:**
   - Проверка дали ключ съществува (contains)
   - Обхождане на всички елементи (iterate)
   - Броене на елементите (size)

2. **Подобрете надеждността:**
   - Обработка на грешки
   - Проверка на указатели преди използване
   - Валидация на входните данни

3. **Оптимизирайте:**
   - Измерете времето за операциите
   - Сравнете различни размери на таблицата
   - Експериментирайте с различни хеш-функции

---

## 10. КОНТРОЛНИ ВЪПРОСИ

1. Каква е целта на хеш-функцията в програмата?

2. Защо е избрано простото число 211 за размер на таблицата?

3. Какво представлява колизия и как се управлява в тази реализация?

4. Каква е времевата сложност на операцията get() в среден и най-лош случай?

5. Какви проблеми могат да възникнат при многократно извикване на put() със същия ключ?

6. Защо вмъкването става в началото на списъка, а не в края?

7. Какво ще се случи, ако всички елементи попаднат в една позиция на таблицата?

8. Как може да се подобри функцията get(), за да разграничава липсващи елементи от елементи със стойност -1?

9. Какви са предимствата на свързването (chaining) пред отворено адресиране (open addressing)?

10. Как може да се реализира операция за премахване на всички елементи с дадена стойност (не ключ)?

---

## 11. ЗАКЛЮЧЕНИЕ

Представената реализация на хеш-таблица демонстрира фундаментални концепции в структурите от данни:

- **Хеширане:** Ефективно преобразуване на ключове в индекси
- **Управление на колизии:** Използване на свързани списъци
- **Динамична памет:** Гъвкаво разпределение според нуждите
- **Компромиси:** Баланс между време, памет и простота

Програмата е отличен фундамент за разбиране на по-сложни структури като:
- Многомерни хеш-таблици
- Самобалансиращи се хеш-таблици
- Разпределени хеш-таблици

**Препоръки за по-нататъшно изучаване:**
1. Имплементирайте динамично преоразмеряване (rehashing)
2. Сравнете с други методи за управление на колизии
3. Измерете производителността при различни сценарии
4. Проучете стандартните библиотеки (std::unordered_map)

---

**Съставил:** Гл. ас. д-р Светослав Атанасов  
**Дисциплина:** Алгоритми и структури от данни  
**Учебно заведение:** Тракийски университет - Стара Загора  
**Учебна година:** 2024/2025
