# Двоични дървета - Пълна информация и код

## 1. Определения

### Дърво (Tree)
Динамична информационна структура, състояща се от елементи (върхове) и връзки между тях (дъги), в която:
- Всички върхове без 1 имат по 1 предшественик
- 1 връх (корен) няма предшественици
- Единствен път до корена
- **Ниво на върха** - брой на върховете в пътя до корена
- **Корен** - ниво 0
- **Листа** - върхове без наследници
- **Поддърво** - върхът и всичките му наследници, техните наследници и т.н.
- Рекурсивна същност на дърветата като структури от данни

### Двоично дърво (Binary Tree)
- Брой на наследниците на върховете: 0, 1 или 2
- Ляв и десен наследник

### Рекурсивно определение на двоично дърво
Крайно множество от елементи (възли), което е или **празно**, или се състои от **корен** (възел), свързан с две непресичащи се двоични дървета (поддървета) - **ляво** и **дясно** поддърво.

## 2. Аритметични изрази и двоични дървета
- Листата са имена на променливи и константи
- Другите възли са аритметични операции
- Пример: (a+b) / ((c+f) - (e*d))

## 3. Обхождане на двоично дърво

![Пример на двоично дърво](binary_tree_example2.png)

Линейно нареждане на възлите на дървото:
1. **preorder (клд – корен, ляво, дясно)** → `/+ab-+cf*ed`
2. **inorder (лкд – ляво, корен, дясно)** → `a+b/c+f-e*d`
3. **postorder (лдк – ляво, дясно, корен)** - `ab+cf+ed*-/`

## Пример на двоично дърво

![Пример на двоично дърво](binary_tree_example.png)

*Пример: Двоично дърво с корен 2 и наследници. InOrder обхождане дава: 2, 7, 2, 6, 5, 11, 5, 9, 4*

### Примерни резултати от обхождане:
За дърво с върхове: 2 (корен), 7, 5, 2, 6, 9, 5, 11, 4

- **КДЛ**: 2;5;9;4;7;6;11;5;2
- **ДКЛ**: 9;4;5;2;11;6;5;7;2
- **ДЛК**: 4;9;5;11;5;6;2;7;2
- **КЛД**: 2;7;2;6;5;11;5;9;4
- **ЛКД**: 2;7;5;6;11;2;5;4;9
- **ЛДК**: 2;5;11;6;7;4;9;5;2

## 4. Двоично дърво за претърсване (Binary Search Tree)

### Определение
Двоичното дърво за претърсване е структура от данни, която служи за съхраняване и намиране на данни по ключ, за който съществува наредба.

**Данните са разпределени в дървото по следния начин:**
- За всеки връх, всички данни в **лявото му поддърво** имат **по-малък ключ**
- Всички данни в **дясното поддърво** имат **по-голям ключ**

**Примери:**
- 10,  5, 15,  3, 8, 12, 20
-  5,  3,  7,  2, 4,  6,  9
-  7, 15, 10, 20, 8, 12, 17, 25, 15

### Ефикасност на двоичните дървета за търсене
- **Средна сложност** на операциите добавяне и търсене: **O(log N)**, където N е броят на елементите
- При добавяне на подредени елементи дървото може да се изроди до свързан списък → сложност **O(N)**
- Съществуват алгоритми (балансирани дървета), които поддържат структурата балансирана и запазват добрите сложности

### Изключване на връх по даден ключ

Тази операция е малко по-сложна. След намиране на върха с ключ k, са възможни 3 ситуации:

1. **Ако върхът е листо** - освобождава се заетата памет и се променя указателят на върха, сочещ към него (присвоява му се стойност NULL)

2. **Ако върхът има само ляво или само дясно поддърво** - се замества с корена на това поддърво

3. **Най-сложният случай** - когато върхът за изтриване p има едновременно ляво и дясно поддърво:
   - Намира се върхът с **най-малък ключ в дясното поддърво** (най-левият в дясното поддърво)
   - Този връх се разменя с p
   - След размяната p ще има най-много едно поддърво и се изключва по някое от горните две правила
   - (Алтернатива: намиране на елемента с най-голям ключ в лявото поддърво)

## 5. Програмен код

### Основна структура

```cpp
#include <iostream>
using namespace std;

struct tnode {
    int i;
    tnode* left;
    tnode* right;
};
```

### Функции за обхождане

#### 1. PreOrder (КЛД - Корен, Ляво, Дясно)
```cpp
void printPREORDER(tnode* tree) {
    if (tree != NULL) {
        cout << tree->i << endl;
        printPREORDER(tree->left);
        printPREORDER(tree->right);
    }
}
```

#### 2. InOrder (ЛКД - Ляво, Корен, Дясно)
```cpp
void printINORDER(tnode* tree) {
    if (tree != NULL) {
        printINORDER(tree->left);
        cout << tree->i << endl;
        printINORDER(tree->right);
    }
}
```

#### 3. PostOrder (ЛДК - Ляво, Дясно, Корен)
```cpp
void printPOSTORDER(tnode* tree) {
    if (tree != NULL) {
        printPOSTORDER(tree->left);
        printPOSTORDER(tree->right);
        cout << tree->i << endl;
    }
}
```

### Функции за работа с дървото

#### 4. Добавяне на възел
```cpp
tnode* addnode(int x, tnode* &tree) {
    if (tree == NULL) {
        tree = new tnode;
        tree->i = x;
        tree->left = NULL;
        tree->right = NULL;
    } else if (x < tree->i) {
        tree->left = addnode(x, tree->left);
    } else {
        tree->right = addnode(x, tree->right);
    }
    return tree;
}
```

#### 5. Намиране на минимален елемент
```cpp
tnode* findMin(tnode* tree) {
    while (tree->left != NULL) {
        tree = tree->left;
    }
    return tree;
}
```

#### 6. Изключване от двоично дърво
```cpp
void deleteKey(int x, tnode* &tree) {
    if (tree == NULL) {
        cout << "Nyama element\n";
    } else {
        if (x < tree->i) {
            deleteKey(x, tree->left);
        } else if (x > tree->i) {
            deleteKey(x, tree->right);
        } else {
            /* елементът за изключване е намерен */
            if (tree->left && tree->right) {
                /* върхът има два наследника */
                /* намира се върхът за размяна */
                tnode* replace = findMin(tree->right);
                tree->i = replace->i;
                deleteKey(tree->i, tree->right); /* върхът се изключва */
            } else {
                /* елементът има нула или едно поддървета */
                tnode* temp = tree;
                if (tree->left) {
                    tree = tree->left;
                } else {
                    tree = tree->right;
                }
                delete(temp);
            }
        }
    }
}
```

### Допълнителни функции

#### 7. Търсене на елемент
```cpp
bool Search(tnode* tree, int x) {
    if (tree == NULL) return false;
    if (tree->i == x) return true;
    if (x < tree->i) return Search(tree->left, x);
    else return Search(tree->right, x);
}
```

#### 8. Намиране на дълбочина на дърво
```cpp
int MaxLen(tnode* tree) {
    if (tree == NULL) return -1;
    int l, r;
    l = MaxLen(tree->left);
    r = MaxLen(tree->right);
    if (l > r) return l + 1;
    else return r + 1;
}
```

#### 9. Преброяване на общия брой върхове
```cpp
int Count(tnode* tree) {
    if (tree == NULL) return 0;
    return Count(tree->left) + Count(tree->right) + 1;
}
```

### Пълна програма - 127 реда

```cpp
#include <iostream>
using namespace std;

struct tnode {
    int i;
    tnode* left;
    tnode* right;
};

void printPREORDER(tnode* tree) {
    if (tree != NULL) {
        cout << tree->i << endl;
        printPREORDER(tree->left);
        printPREORDER(tree->right);
    }
}

void printINORDER(tnode* tree) {
    if (tree != NULL) {
        printINORDER(tree->left);
        cout << tree->i << endl;
        printINORDER(tree->right);
    }
}

void printPOSTORDER(tnode* tree) {
    if (tree != NULL) {
        printPOSTORDER(tree->left);
        printPOSTORDER(tree->right);
        cout << tree->i << endl;
    }
}

tnode* addnode(int x, tnode* &tree) {
    if (tree == NULL) {
        tree = new tnode;
        tree->i = x;
        tree->left = NULL;
        tree->right = NULL;
    } else if (x < tree->i) {
        tree->left = addnode(x, tree->left);
    } else {
        tree->right = addnode(x, tree->right);
    }
    return tree;
}

tnode* findMin(tnode* tree) {
    while (tree->left != NULL) {
        tree = tree->left;
    }
    return tree;
}

void deleteKey(int x, tnode* &tree) {
    if (tree == NULL) {
        cout << "Nyama element\n";
    } else {
        if (x < tree->i) {
            deleteKey(x, tree->left);
        } else if (x > tree->i) {
            deleteKey(x, tree->right);
        } else {
            if (tree->left && tree->right) {
                tnode* replace = findMin(tree->right);
                tree->i = replace->i;
                deleteKey(tree->i, tree->right);
            } else {
                tnode* temp = tree;
                if (tree->left) {
                    tree = tree->left;
                } else {
                    tree = tree->right;
                }
                delete(temp);
            }
        }
    }
}

bool Search(tnode* tree, int x) {
    if (tree == NULL) return false;
    if (tree->i == x) return true;
    if (x < tree->i) return Search(tree->left, x);
    else return Search(tree->right, x);
}

int MaxLen(tnode* tree) {
    if (tree == NULL) return -1;
    int l, r;
    l = MaxLen(tree->left);
    r = MaxLen(tree->right);
    if (l > r) return l + 1;
    else return r + 1;
}

int Count(tnode* tree) {
    if (tree == NULL) return 0;
    return Count(tree->left) + Count(tree->right) + 1;
}

int main() {
    tnode* tree = NULL;
    int i, n, a;
    
    cin >> n;
    for (i = 1; i <= n; i++) {
        cin >> a;
        tree = addnode(a, tree);
    }
    
    cout << endl;
    printINORDER(tree);
    cout << endl;
    
    cin >> a;
    deleteKey(a, tree);
    
    cout << endl;
    printINORDER(tree);
    
    // Допълнително можете да използвате:
    // cout << endl << Count(tree) << endl;
    // cout << endl << MaxLen(tree) << endl;
    
    return 0;
}
```

### Пълна програма с детайлни коментари - 406 реда

```cpp
// ============================================================
// ДВОИЧНО ДЪРВО ЗА ПРЕТЪРСВАНЕ - Образователна версия с детайлни коментари
// ============================================================
// Тази имплементация демонстрира Двоично Дърво за Претърсване (BST) с:
// - Три метода на обхождане (PreOrder, InOrder, PostOrder)
// - Операции за добавяне и изтриване на възли
// - Допълнителни помощни функции (Search, Count, MaxLen)
// ============================================================

#include <iostream>
#include <windows.h>
#include <clocale>
using namespace std;

// ============================================================
// ДЕФИНИЦИЯ НА СТРУКТУРАТА ОТ ДАННИ
// ============================================================

struct tnode {
    int i;           // Информационна част - стойността съхранена във възела
    tnode* left;     // Указател към ляво дете (по-малки стойности)
    tnode* right;    // Указател към дясно дете (по-големи стойности)
};

// ============================================================
// ФУНКЦИИ ЗА ОБХОЖДАНЕ НА ДЪРВОТО
// ============================================================
// Времева сложност: O(n) за всички методи на обхождане
// Пространствена сложност: O(h) поради рекурсивен стек, където h е височината
// ============================================================

// PreOrder обхождане (Корен-Ляво-Дясно)
// Приложение: Копиране на дърво, пресмятане на префиксни изрази
// Процес: 1. Посети корена  2. Обходи лявото поддърво  3. Обходи дясното поддърво
void printPREORDER(tnode* tree) {
    if (tree != NULL) {
        cout << tree->i << endl;      // Стъпка 1: Обработи корена първи
        printPREORDER(tree->left);    // Стъпка 2: Рекурсивно обходи ляво
        printPREORDER(tree->right);   // Стъпка 3: Рекурсивно обходи дясно
    }
}

// InOrder обхождане (Ляво-Корен-Дясно)
// Приложение: Получаване на сортиран изход от BST
// Процес: 1. Обходи лявото поддърво  2. Посети корена  3. Обходи дясното поддърво
// ВАЖНО: За BST това дава СОРТИРАН ИЗХОД
void printINORDER(tnode* tree) {
    if (tree != NULL) {
        printINORDER(tree->left);     // Стъпка 1: Обработи малките стойности първи
        cout << tree->i << endl;      // Стъпка 2: Обработи текущия възел
        printINORDER(tree->right);    // Стъпка 3: Обработи големите стойности последни
    }
}

// PostOrder обхождане (Ляво-Дясно-Корен)
// Приложение: Изтриване на дърво, пресмятане на постфиксни изрази
// Процес: 1. Обходи лявото поддърво  2. Обходи дясното поддърво  3. Посети корена
void printPOSTORDER(tnode* tree) {
    if (tree != NULL) {
        printPOSTORDER(tree->left);   // Стъпка 1: Обработи левите деца първи
        printPOSTORDER(tree->right);  // Стъпка 2: Обработи десните деца
        cout << tree->i << endl;      // Стъпка 3: Обработи корена последен
    }
}

// ============================================================
// ФУНКЦИИ ЗА МОДИФИКАЦИЯ НА ДЪРВОТО
// ============================================================

// Добавяне на нов възел в Двоичното Дърво за Претърсване
// Времева сложност: O(h) където h е височината на дървото
//   - Най-добър случай (балансирано): O(log n)
//   - Най-лош случай (небалансирано/линейно): O(n)
// Пространствена сложност: O(h) за рекурсивен стек
//
// КАК РАБОТИ:
// 1. Ако дървото е празно, създай нов възел като корен
// 2. Ако стойността < текущ възел, вмъкни в ЛЯВО поддърво (запазва BST свойството)
// 3. Ако стойността >= текущ възел, вмъкни в ДЯСНО поддърво
// 4. Върни указател за поддържане на връзките в дървото
//
// ЗАЩО използваме референция (&tree):
// Трябва да модифицираме действителния указател, не само копие, за да
// родителските възли правилно да се свързват с новосъздадените деца
tnode* addnode(int x, tnode* &tree) {
    if (tree == NULL) {
        // Базов случай: Намерена точка за вмъкване
        tree = new tnode;           // Заделяне на памет за нов възел
        tree->i = x;                // Задаване на стойността
        tree->left = NULL;          // Новият възел няма деца
        tree->right = NULL;
    } else if (x < tree->i) {
        // Рекурсивен случай: Стойността е по-малка, иди наляво
        tree->left = addnode(x, tree->left);
    } else {
        // Рекурсивен случай: Стойността е по-голяма или равна, иди надясно
        tree->right = addnode(x, tree->right);
    }
    return tree;  // Върни указател за поддържане на връзките родител-дете
}

// Намиране на минималния елемент в дърво/поддърво
// Времева сложност: O(h)
// Пространствена сложност: O(1) - итеративен подход
//
// КАК РАБОТИ:
// В BST минималният елемент винаги е най-левият възел
// Продължаваме наляво докато има леви деца
//
// ЗАЩО е необходима:
// Използва се в deleteKey при премахване на възел с две деца
// Трябва да намерим in-order наследника (най-малкия в дясното поддърво)
tnode* findMin(tnode* tree) {
    while (tree->left != NULL) {
        tree = tree->left;  // Продължаваме наляво
    }
    return tree;  // Това е най-левият (минимален) възел
}

// Изтриване на възел с дадена стойност от дървото
// Времева сложност: O(h)
// Пространствена сложност: O(h) за рекурсивен стек
//
// КАК РАБОТИ - Три случая:
// Случай 1: Възелът е лист (няма деца)
//         → Просто го изтриваме и задаваме указателя на родителя на NULL
// Случай 2: Възелът има едно дете
//         → Заместваме възела с неговото дете
// Случай 3: Възелът има две деца (СЛОЖЕН СЛУЧАЙ)
//         → Намираме in-order наследника (най-малкия в дясното поддърво)
//         → Копираме стойността на наследника в текущия възел
//         → Изтриваме наследника (който има най-много едно дете)
//
// ЗАЩО Случай 3 е сложен:
// Не можем просто да изтрием възел с две деца, защото ще загубим
// връзките към двете поддървета. Вместо това го заместваме с неговия
// in-order наследник, за да запазим BST свойството.
void deleteKey(int x, tnode* &tree) {
    if (tree == NULL) {
        // Елементът не е намерен в дървото
        cout << "Елементът не е намерен\n";
        return;
    }

    // Търсене на елемента
    if (x < tree->i) {
        // Елементът трябва да е в лявото поддърво
        deleteKey(x, tree->left);
    } else if (x > tree->i) {
        // Елементът трябва да е в дясното поддърво
        deleteKey(x, tree->right);
    } else {
        // Намерен е елементът за изтриване

        // Случай 3: Възелът има ДВЕ деца (най-сложен)
        if (tree->left && tree->right) {
            // Намираме най-малкия елемент в дясното поддърво (in-order наследник)
            tnode* replace = findMin(tree->right);

            // Копираме стойността на наследника в текущия възел
            // (Заместваме стойността, не самия възел)
            tree->i = replace->i;

            // Сега изтриваме наследника от дясното поддърво
            // Това рекурсивно извикване ще обработи Случай 1 или 2
            deleteKey(tree->i, tree->right);
        } else {
            // Случай 1 и 2: Възелът има НУЛА или ЕДНО дете
            tnode* temp = tree;  // Запазваме възела за изтриване

            // Ако има ляво дете, повишаваме го; иначе повишаваме дясното дете
            // (Ако и двете са NULL, tree става NULL - обработва Случай 1)
            if (tree->left) {
                tree = tree->left;
            } else {
                tree = tree->right;
            }

            delete temp;  // Освобождаваме паметта
        }
    }
}

// ============================================================
// ДОПЪЛНИТЕЛНИ ПОМОЩНИ ФУНКЦИИ
// ============================================================

// Търсене на елемент в дървото
// Времева сложност: O(h)
// Пространствена сложност: O(h) за рекурсия
//
// Връща true ако елементът съществува, false иначе
// Използва BST свойството за ефективно търсене
bool Search(tnode* tree, int x) {
    if (tree == NULL) return false;           // Не е намерен
    if (tree->i == x) return true;            // Намерен е!
    if (x < tree->i) return Search(tree->left, x);   // Търси наляво
    else return Search(tree->right, x);              // Търси надясно
}

// Намиране на дълбочината (височината) на дървото
// Времева сложност: O(n) - трябва да посетим всички възли
// Пространствена сложност: O(h) за рекурсия
//
// КАК РАБОТИ:
// Рекурсивно намираме дълбочината на лявото и дясното поддърво,
// след което връщаме максималната плюс 1 (за текущото ниво)
//
// Връща -1 за празно дърво, 0 за единичен възел (само корен)
int MaxLen(tnode* tree) {
    if (tree == NULL) return -1;  // Празно дърво

    // Рекурсивно намираме дълбочината на двете поддървета
    int l = MaxLen(tree->left);
    int r = MaxLen(tree->right);

    // Връщаме по-голямата дълбочина плюс 1 за текущия възел
    if (l > r) return l + 1;
    else return r + 1;
}

// Преброяване на общия брой възли в дървото
// Времева сложност: O(n) - трябва да посетим всички възли
// Пространствена сложност: O(h) за рекурсия
//
// КАК РАБОТИ:
// Рекурсивно броим възлите в ляво поддърво + дясно поддърво + 1 (текущ възел)
int Count(tnode* tree) {
    if (tree == NULL) return 0;  // Празното дърво има 0 възела

    // Брой = ляво поддърво + дясно поддърво + текущ възел
    return Count(tree->left) + Count(tree->right) + 1;
}

// Освобождаване на цялата заделена памет за дървото
// Времева сложност: O(n)
// Пространствена сложност: O(h) за рекурсия
//
// Използва PostOrder обхождане (децата преди родителя)
// за безопасно изтриване на всички възли
void deleteTree(tnode* tree) {
    if (tree != NULL) {
        deleteTree(tree->left);   // Изтрий лявото поддърво първо
        deleteTree(tree->right);  // Изтрий дясното поддърво
        delete tree;              // Накрая изтрий текущия възел
    }
}

// ============================================================
// ГЛАВНА ПРОГРАМА
// ============================================================

int main() {
    // WINDOWS - За правилна кирилица:
    system("chcp 65001 > nul");
    SetConsoleCP(65001);
    SetConsoleOutputCP(65001);
    setlocale(LC_ALL, ".UTF-8");

    tnode* tree = NULL;  // Инициализиране на празно дърво (указател към корена)
    int i, n, a;


    // Вход: Създаване на началното дърво
    cout << "Въведете брой елементи: ";
    cin >> n;

    for (i = 1; i <= n; i++) {
        cout << "Въведете елемент " << i << ": ";
        cin >> a;
        tree = addnode(a, tree);  // Добавяне на всеки елемент в дървото
    }

    // Показване: Извеждане на дървото в сортиран ред
    cout << "\nInOrder обхождане:\n";
    printINORDER(tree);  // Това показва елементите в сортиран ред

    // Изтриване: Премахване на един елемент
    cout << "\nВъведете елемент за изтриване: ";
    cin >> a;
    deleteKey(a, tree);

    // Показване: Извеждане на дървото след изтриването
    cout << "\nInOrder обхождане след изтриване:\n";
    printINORDER(tree);


    // ============================================================
    // УПРАЖНЕНИЯ ЗА СТУДЕНТИТЕ
    // ============================================================
    // Функциите Search(), MaxLen(), Count(), printPREORDER(),
    // printPOSTORDER() и deleteTree() са дефинирани, но не всички
    // се използват. Вашата задача е да ги извикате на правилните места.
    // ============================================================

    // ЗАДАЧА 1: Добавете извикване на Search()
    // Проверете дали елемент 15 съществува в дървото
    // Ако е намерен, изведете "Намерен 15", иначе "15 не е намерен"
    // Подсказка: if (Search(tree, 15)) { ... } else { ... }

    // ДОБАВЕТЕ РЕШЕНИЕТО ТУК:



    // ЗАДАЧА 2: Добавете извикване на Count()
    // Изведете броя на оставащите възли след изтриването
    // Формат: cout << "Брой: " << ... << endl;

    // ДОБАВЕТЕ РЕШЕНИЕТО ТУК:



    // ЗАДАЧА 3: Добавете извикване на MaxLen()
    // Изведете дълбочината (височината) на дървото
    // Формат: cout << "Дълбочина: " << ... << endl;

    // ДОБАВЕТЕ РЕШЕНИЕТО ТУК:



    // ЗАДАЧА 4: Заменете функцията за обхождане
    // Намерете ред 235 (първото извикване на printINORDER) и го заменете с printPREORDER
    // Това ще покаже дървото в различен ред (Корен-Ляво-Дясно)



    // ЗАДАЧА 5: Използвайте printPOSTORDER
    // Добавете извикване на printPOSTORDER(tree) за да видите post-order обхождане
    // Това посещава децата преди родителите

    // ДОБАВЕТЕ РЕШЕНИЕТО ТУК:



    // ЗАДАЧА 6: Освободете паметта
    // Преди return 0, добавете deleteTree(tree) за да освободите цялата заделена памет
    // Това е важно за предотвратяване на изтичане на памет


    return 0;
    // ТУК (НАД return 0) трябва да добавите deleteTree(tree);
}

// ============================================================
// ОБОБЩЕН АНАЛИЗ НА СЛОЖНОСТТА
// ============================================================
//
// ВРЕМЕВА СЛОЖНОСТ:
//
// Основни операции (зависят от височината h на дървото):
//   - addnode():     O(h) за вмъкване
//   - deleteKey():   O(h) за изтриване
//   - Search():      O(h) за търсене
//   - findMin():     O(h)
//
//   където h = височина на дървото:
//     * Балансирано дърво:    h = O(log n) → операциите са O(log n)
//     * Небалансирано дърво:  h = O(n)     → операциите се влошават до O(n)
//
// Операции за обхождане (трябва да посетят всички възли):
//   - printINORDER():    O(n)
//   - printPREORDER():   O(n)
//   - printPOSTORDER():  O(n)
//   - Count():           O(n)
//   - MaxLen():          O(n)
//   - deleteTree():      O(n)
//
// ПРОСТРАНСТВЕНА СЛОЖНОСТ:
//   - Съхранение на дървото:  O(n) - n възела в паметта
//   - Рекурсивен стек:        O(h) за всички рекурсивни функции
//     * Балансирано дърво:    O(log n)
//     * Небалансирано дърво:  O(n)
//
// НАЙ-ЛОШ СЦЕНАРИЙ:
// Когато елементите се вмъкват в сортиран ред (напр. 1,2,3,4,5...),
// дървото дегенерира в свързан списък:
//     1
//      \
//       2
//        \
//         3
//          \
//           4
//            \
//             5
// В този случай всички операции стават O(n).
//
// РЕШЕНИЕ: Използвайте самобалансиращи се дървета (AVL, Red-Black) за
// поддържане на O(log n) производителност независимо от реда на вмъкване.
//
// ============================================================
// СРАВНЕНИЕ С ДРУГИ СТРУКТУРИ ОТ ДАННИ:
// ============================================================
//
// Операция     | BST (средно) | BST (най-лошо) | Сорт. масив | Свързан списък
// -------------|--------------|----------------|-------------|----------------
// Търсене      | O(log n)     | O(n)           | O(log n)    | O(n)
// Вмъкване     | O(log n)     | O(n)           | O(n)        | O(1)*
// Изтриване    | O(log n)     | O(n)           | O(n)        | O(n)
// Мин/Макс     | O(log n)     | O(n)           | O(1)        | O(n)
// Сорт. ред    | O(n)         | O(n)           | O(n)        | O(n log n)
//
// * Вмъкване в свързан списък е O(1) само при вмъкване в началото/края;
//   поддържането на сортиран ред изисква O(n)
//
// ============================================================
```

## 6. Примери за използване

### Вход:
```
7
15 10 20 8 12 17 25
15
```

### Изход:
```
8 10 12 15 17 20 25
(след изтриване на 15)
8 10 12 17 20 25
```

## Забележки:
- InOrder обхождането на двоично дърво за претърсване дава **сортиран изход**
- Всички операции са **рекурсивни** по природа
- Дълбочината се измерва от -1 (празно дърво) до 0 (само корен) и нагоре
- При изтриване на възел с две деца, алгоритъмът използва най-малкия елемент от дясното поддърво като заместител
