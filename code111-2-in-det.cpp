#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>

using namespace std;

int n, v, used[101];       // Брой върхове (n), начален връх за обхождане (v), масив за маркиране на посетените върхове
queue<int> q;              // Опашка за BFS обхождане
vector<int> a[101];        // Списък на съседство за графа

// Функция за обхождане в широчина (BFS)
void bfs() {
	// Поставяме началния връх в опашката
	q.push(v);
	// Маркираме го като посетен
	used[v] = 1;

	// Докато опашката не е празна
	while (!q.empty()) {
		// Извличаме първия връх от опашката
		int t = q.front();
		q.pop(); // Премахваме го от опашката

		// Извеждаме текущия връх
		printf("%d ", t);

		// Обхождаме всички съседи на текущия връх
		for (int i = 0; i < a[t].size(); i++) {
			// Ако съседът не е посетен
			if (used[a[t][i]] == 0) {
				// Добавяме го в опашката
				q.push(a[t][i]);
				// Маркираме го като посетен
				used[a[t][i]] = 1;
			}
		}
	}
}

int main() {
	// Въвеждаме броя върхове и началния връх за обхождане
	cout << "Enter the number of vertices and the starting vertex:" << endl;
	scanf("%d %d", &n, &v);

	int b, c; // Начален (b) и краен (c) връх на ребро

	cout << "Enter edges (enter '0 0' to stop):" << endl;
	// Въвеждаме ръбовете на графа
	while (true) {
		scanf("%d %d", &b, &c);
		// Проверка за край на въвеждането
		if (b == 0 && c == 0) break;

		// Добавяме ръбовете към списъка на съседство (графът е неориентиран)
		a[b].push_back(c);
		a[c].push_back(b);
	}

	// Започваме обхождането с BFS от началния връх
	bfs();
	printf("\n");

	return 0;
}

/*
### Обяснения:
1. **Инициализация:**
   - `used[101]` маркира кои върхове са посетени (1 за посетен, 0 за непосетен).
   - `q` е опашка, използвана за поддържане на реда на посещение в BFS.
   - `a[101]` е списък на съседство, представляващ графа.

2. **Функция `bfs`:**
   - Началният връх се добавя в опашката и се маркира като посетен.
   - Докато опашката не е празна:
     - Извличаме текущия връх от опашката и го отпечатваме.
     - За всеки негов съсед:
       - Ако съседът не е посетен, го добавяме в опашката и го маркираме.

3. **Основна програма:**
   - Чете броя на върховете и началния връх за обхождане.
   - Чете ръбовете на графа, докато се въведе `0 0` като край.
   - BFS обхожда графа, започвайки от зададения начален връх.

4. **Примерни действия:**
   - Поставя началния връх в опашката, отпечатва го и обхожда всички негови съседи.
   - Процесът продължава, докато всички върхове бъдат посетени.
*/
