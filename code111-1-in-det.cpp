#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

int n, v, used[101]; // Брой върхове (n), начален връх за обхождане (v), масив за маркиране на посетените върхове
vector<int> a[101];  // Списък на съседство, представен като двумерен масив чрез вектори

// Функция за дълбочинно първо търсене (DFS) от връх k
void dfs(int k) {
	// Извеждане на текущия връх
	printf("%d ", k);

	// Обхождане на всички съседи на текущия връх
	for (int i = 0; i < a[k].size(); i++) {
		// Ако съседният връх вече е посетен, пропускаме го
		if (used[a[k][i]]) continue;

		// Маркираме върха като посетен
		used[a[k][i]] = 1;
		// Рекурсивно обхождаме съседния връх
		dfs(a[k][i]);
	}
}

int main() {
	// Въвеждане на броя върхове и началния връх за обхождане
	cout << "Enter the number of vertices and the starting vertex:" << endl;
	scanf("%d %d", &n, &v); // Брой върхове (n) и начален връх (v)

	int b, c; // Начален (b) и краен (c) връх на ребро

	cout << "Enter edges (enter '0 0' to stop):" << endl;
	// Въвеждане на ръбовете на графа
	while (true) {
		scanf("%d %d", &b, &c);
		// Спиране при въвеждане на 0 0 (условие за край на въвеждането)
		if (b == 0 && c == 0) break;

		// Добавяне на ръбовете към списъка на съседство
		// Тъй като графът е неориентиран, добавяме ръбовете симетрично
		a[b].push_back(c);
		a[c].push_back(b);
	}

	// Сортиране на съседите на всеки връх във възходящ ред
	// Това осигурява обхождане на върховете в нарастващ ред
	for (int i = 0; i < n; i++) {
		sort(a[i].begin(), a[i].end());
	}

	// Маркираме началния връх като посетен
	used[v] = 1;
	// Започваме обхождането чрез DFS от началния връх
	dfs(v);

	return 0;
}
