# 📚 Упражнение № 06: Указатели и динамични структури

## 🎯 Пълно методическо ръководство с детайлни обяснения и визуализации

**От основи на паметта до динамични структури - всичко обяснено стъпка по стъпка**

---

## 📋 Съдържание

### ЧАСТ 1: Указатели (Pointers):
1. [Какво е памет?](#memory) - Как работи оперативната памет
2. [Адреси в паметта](#addresses) - Какво е адрес
3. [Какво са указатели?](#pointers) - Основна концепция
4. [Декларация на указатели](#declaration) - Синтаксис
5. [Операции с указатели](#operations) - & и *
6. [NULL указатели](#null) - Празни указатели

### ЧАСТ 2: Динамична памет:
7. [new и delete](#new-delete) - Динамично заделяне
8. [Масиви с new](#dynamic-arrays) - Динамични масиви
9. [Memory Leaks](#memory-leaks) - Изтичане на памет

### ЧАСТ 3: Динамични структури:
10. [Свързани списъци](#linked-lists) - Основна структура
11. [Стек и опашка](#stack-queue) - Реализация със списъци
12. [Дървета](#trees) - Двоични дървета

### Допълнително:
13. [Често срещани грешки](#common-mistakes)
14. [Best Practices](#best-practices)

---

<a name="memory"></a>
## 📌 ЧАСТ 1: Какво е памет?

### 🎯 Оперативна памет (RAM)

**Оперативната памет** (ОП) е като огромен шкаф с кутийки, където всяка кутийка може да съхранява данни.

```
╔════════════════════════════════════════════════════════╗
║ ПРЕДСТАВА ЗА ПАМЕТТА                                   ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║    Паметта е като АПАРТАМЕНТИ в блок:                 ║
║                                                        ║
║    ┌─────────────────────────────────────────┐        ║
║    │ Апартамент 0x1000:  [данни]            │        ║
║    ├─────────────────────────────────────────┤        ║
║    │ Апартамент 0x1004:  [данни]            │        ║
║    ├─────────────────────────────────────────┤        ║
║    │ Апартамент 0x1008:  [данни]            │        ║
║    ├─────────────────────────────────────────┤        ║
║    │ Апартамент 0x100C:  [данни]            │        ║
║    └─────────────────────────────────────────┘        ║
║                                                        ║
║    Всеки апартамент има АДРЕС (0x1000, 0x1004...)    ║
╚════════════════════════════════════════════════════════╝
```

### 📊 Визуализация на паметта

```
═══════════════════════════════════════════════════════════
ПАМЕТ В КОМПЮТЪРА:
═══════════════════════════════════════════════════════════

Адрес     │ Съдържание   │ Обяснение
──────────┼──────────────┼────────────────────────────────
0x0000    │              │ Операционна система
0x0004    │              │ 
...       │              │
0x1000    │    10        │ ← int a = 10;
0x1004    │    20        │ ← int b = 20;
0x1008    │  0x1000      │ ← int* pa = &a; (адрес на a!)
0x100C    │    30        │ ← int c = 30;
...       │              │
0xFFFF    │              │ Край на паметта

═══════════════════════════════════════════════════════════

🔑 КЛЮЧОВИ ПОНЯТИЯ:
   • Всяка променлива заема място в паметта
   • Всяка клетка има уникален АДРЕС
   • Адресът е число (обикновено в шестнайсетичен вид)
   • int заема 4 байта (адреси се увеличават с 4)
```

---

<a name="addresses"></a>
## 📌 Адреси в паметта

### 🎯 Какво е адрес?

**Адрес** е номерът на "апартамента" в паметта, където се намира променливата.

```cpp
int a = 10;

// Къде се намира променливата a в паметта?
// Отговор: На някакъв адрес, например 0x1000

cout << &a;  // Извежда адреса: 0x1000
```

### 🔍 Оператор & (адрес на)

Операторът `&` връща **адреса** на променлива.

```cpp
int x = 42;

cout << x;   // Извежда: 42 (стойността)
cout << &x;  // Извежда: 0x7ffe5367e044 (адреса)
```

**Визуализация:**

```
═══════════════════════════════════════════════════════════
int x = 42;
═══════════════════════════════════════════════════════════

             ┌──────────────────┐
    ПАМЕТ:   │  Адрес: 0x1000   │
             ├──────────────────┤
             │  Стойност: 42    │
             └──────────────────┘
                      ↑
                      │
                  Променлива x

x       → Стойността (42)
&x      → Адресът (0x1000)

═══════════════════════════════════════════════════════════
```

---

<a name="pointers"></a>
## 📌 Какво са указатели?

### 🎯 Определение

**Указател** (pointer) е променлива, която съхранява **АДРЕС** на друга променлива.

```
╔════════════════════════════════════════════════════════╗
║ ОБИКНОВЕНА ПРОМЕНЛИВА vs УКАЗАТЕЛ                      ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  ОБИКНОВЕНА ПРОМЕНЛИВА:                                ║
║    int x = 42;                                         ║
║    └─► Съхранява СТОЙНОСТ (42)                        ║
║                                                        ║
║  УКАЗАТЕЛ:                                             ║
║    int* p = &x;                                        ║
║    └─► Съхранява АДРЕС (къде е x в паметта)           ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

### 📊 Графична визуализация

```
═══════════════════════════════════════════════════════════
int x = 42;
int* p = &x;
═══════════════════════════════════════════════════════════

ПАМЕТ:

    Променлива x:
    ┌──────────────────┐
    │ Адрес: 0x1000    │
    ├──────────────────┤
    │ Стойност: 42     │  ← x съдържа 42
    └──────────────────┘
           ↑
           │ сочи към
           │
    Указател p:
    ┌──────────────────┐
    │ Адрес: 0x1004    │
    ├──────────────────┤
    │ Стойност: 0x1000 │  ← p съдържа адреса на x!
    └──────────────────┘

🔑 ОБЯСНЕНИЕ:
   • x е на адрес 0x1000 и съдържа 42
   • p е на адрес 0x1004 и съдържа 0x1000
   • p "сочи" към x (съдържа адреса му)

═══════════════════════════════════════════════════════════
```

### 💡 Аналогия

```
╔════════════════════════════════════════════════════════╗
║ АНАЛОГИЯ: Къща и адрес                                 ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  КЪЩ��:           →  Променливата (x = 42)             ║
║    • Съдържа хора/вещи                                 ║
║    • Има физическо съществуване                        ║
║                                                        ║
║  АДРЕС:          →  Адресът на променливата (&x)       ║
║    • "ул. Витоша 10"                                   ║
║    • Казва КЪ��Е е къщата                               ║
║                                                        ║
║  ХАРТИЯ С АДРЕС: →  Указателят (int* p = &x)          ║
║    • Хартия с написано "ул. Витоша 10"                ║
║    • Може да използваш адреса за да намериш къщата    ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

---

<a name="declaration"></a>
## 📌 Декларация на указатели

### 📝 Синтаксис

```cpp
тип* име_на_указател;

// Примери:
int* p;      // Указател към int
double* pd;  // Указател към double
char* pc;    // Указател към char
```

**Звездичката (`*`)** показва че променливата е указател!

### 🎬 Пример 1: Основно използване

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5;           // Обикновена променлива
    int* pa = &a;        // Указател към a
    
    cout << "Стойност на a: " << a << endl;       // 5
    cout << "Адрес на a: " << &a << endl;          // 0x1000
    cout << "Стойност на pa: " << pa << endl;      // 0x1000
    cout << "Адрес на pa: " << &pa << endl;        // 0x1004
    
    return 0;
}
```

**Изход:**

```
Стойност на a: 5
Адрес на a: 0x7ffe5367e044
Стойност на pa: 0x7ffe5367e044  ← Същият адрес!
Адрес на pa: 0x7ffe5367e048
```

### 📊 Визуализация на примера

```
═══════════════════════════════════════════════════════════
ПАМЕТ СЛЕД: int a = 5; int* pa = &a;
═══════════════════════════════════════════════════════════

    a:
    ┌──────────────────────┐
    │ Адрес: 0x...044      │
    ├──────────────────────┤
    │ Стойност: 5          │  ← a = 5
    └──────────────────────┘
             ↑
             │ pa сочи към a
             │
    pa:
    ┌──────────────────────┐
    │ Адрес: 0x...048      │
    ├──────────────────────┤
    │ Стойност: 0x...044   │  ← pa = &a
    └──────────────────────┘

ОБЯСНЕНИЕ:
  a        → 5 (стойността на a)
  &a       → 0x...044 (адресът на a)
  pa       → 0x...044 (съдържанието на pa - адрес на a)
  &pa      → 0x...048 (адресът на самия pa)

═══════════════════════════════════════════════════════════
```

---

<a name="operations"></a>
## 📌 Операции с указатели

### 🔍 Двата основни оператора

```
╔════════════════════════════════════════════════════════╗
║ ОПЕРАТОРИ ЗА УКАЗАТЕЛИ                                 ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  & (Ampersand) - "address of"                          ║
║    → Дава АДРЕСА на променлива                         ║
║    → Пример: &a → адресът където е a                   ║
║                                                        ║
║  * (Asterisk) - "dereference" / "косвен достъп"        ║
║    → Достъпва СТОЙНОСТТА на адреса                     ║
║    → Пример: *pa → стойността на адреса в pa           ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

### 📝 Пълен пример

```cpp
#include <iostream>
using namespace std;

int main() {
    // Инициализация на променливи
    int a = 5, b = -20;
    
    // Декларираме указател, сочещ към променливата 'a'
    int* pa = &a;
    
    // Извеждане на стойността на 'a' и адреса на 'a'
    cout << "Initial value of a = " << a << endl;
    cout << "Pointer 'pa' is pointing to address of a: " << pa << endl;
    
    // Присвояване на нова стойност на 'a' чрез указателя
    *pa = 100;
    
    // Извеждане на новата стойност на 'a' след промяната
    cout << "New value of a = " << a << endl;
    cout << "Pointer 'pa' is still pointing to address of a: " << pa << endl;
    
    // Пренасочване на указателя 'pa' към променливата 'b'
    pa = &b;
    
    // Извеждане на стойността на 'b' и новия адрес
    cout << "Value of b = " << b << endl;
    cout << "Pointer 'pa' is now pointing to address of b: " << pa << endl;
    
    return 0;
}
```

### 🔍 Визуализация стъпка по стъпка

```
═══════════════════════════════════════════════════════════
СТЪПКА 1: int a = 5, b = -20;
═══════════════════════════════════════════════════════════

    ┌──────────────┐     ┌──────────────┐
    │ a = 5        │     │ b = -20      │
    │ @0x1000      │     │ @0x1004      │
    └──────────────┘     └──────────────┘

───────────────────────────────────────────────────────────
СТЪПКА 2: int* pa = &a;
═══════════════════════════════════════════════════════════

    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
    │ a = 5        │ ←── │ pa = 0x1000  │     │ b = -20      │
    │ @0x1000      │     │ @0x1008      │     │ @0x1004      │
    └──────────────┘     └──────────────┘     └──────────────┘
                              │
                              └──► pa сочи към a

───────────────────────────────────────────────────────────
СТЪПКА 3: *pa = 100;  (Променяме a ЧРЕЗ pa!)
═══════════════════════════════════════════════════════════

    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
    │ a = 100 ✓    │ ←── │ pa = 0x1000  │     │ b = -20      │
    │ @0x1000      │     │ @0x1008      │     │ @0x1004      │
    └──────────────┘     └──────────────┘     └──────────────┘
         ↑                    │
         └────────────────────┘
    *pa означава "следвай pa и промени стойността там"
    
───────────────────────────────────────────────────────────
СТЪПКА 4: pa = &b;  (Пренасочваме pa към b!)
═══════════════════════════════════════════════════════════

    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
    │ a = 100      │     │ pa = 0x1004  │ ──► │ b = -20      │
    │ @0x1000      │     │ @0x1008      │     │ @0x1004      │
    └──────────────┘     └──────────────┘     └──────────────┘
                              │
                              └──► pa СЕГА сочи към b

═══════════════════════════════════════════════════════════
```

### 🎯 Ключови операции

```cpp
int a = 10;
int* pa = &a;

// 1️⃣ Вземане на адрес
cout << &a;      // Адресът на a (напр. 0x1000)

// 2️⃣ Присвояване на адрес
pa = &a;         // pa сега съдържа адреса на a

// 3️⃣ Косвен достъп (dereference)
cout << *pa;     // Стойността на адреса в pa → 10

// 4️⃣ Промяна чрез указател
*pa = 20;        // a става 20!

// 5️⃣ Пренасочване
int b = 30;
pa = &b;         // pa сега сочи към b
```

---

<a name="null"></a>
## 📌 NULL указатели

### 🎯 Какво е NULL?

**NULL** (или `nullptr` в C++11) е специална стойност, която означава "указателят не сочи никъде".

```cpp
int* p = NULL;      // C стил
int* p2 = nullptr;  // C++ стил (по-добър!)

// И двата означават: "p не сочи към нищо"
```

### 📊 Визуализация

```
═══════════════════════════════════════════════════════════
NULL УКАЗАТЕЛ:
═══════════════════════════════════════════════════════════

    Указател p:
    ┌──────────────────────┐
    │ Адрес: 0x1000        │
    ├──────────────────────┤
    │ Стойност: 0 (NULL)   │  ← Не сочи никъде!
    └──────────────────────┘
              │
              └─► ∅ (НИКЪДЕ)

⚠️ Опит за достъп до *p ще доведе до грешка!

═══════════════════════════════════════════════════════════
```

### ⚠️ Защо е важен NULL?

```cpp
int* p = nullptr;

// ВИНАГИ проверявай преди използване!
if (p != nullptr) {
    cout << *p << endl;  // Безопасно
} else {
    cout << "Указателят е NULL!" << endl;
}

// ❌ БЕЗ проверка - ОПАСНО!
cout << *p << endl;  // СЕГМЕНТАЦИЯ ГРЕШКА!
```

**Често срещани случаи за NULL:**

```
╔════════════════════════════════════════════════════════╗
║ КОГА ДА ИЗПОЛЗВАМЕ NULL?                               ║
╠════════════════════════════════════════════════════════╣
║ ✅ Инициализация преди да знаем къде сочи              ║
║ ✅ След delete (за да покажем че паметта е освободена) ║
║ ✅ Връщане от функция при грешка                       ║
║ ✅ Край на свързан списък                              ║
╚════════════════════════════════════════════════════════╝
```

---

<a name="new-delete"></a>
## 📌 ЧАСТ 2: Динамична памет (new и delete)

### 🎯 Какво е динамична памет?

**Динамична памет** е памет, която заделяме и освобождаваме **по време на изпълнение** на програмата.

```
╔════════════════════════════════════════════════════════╗
║ СТАТИЧНА vs ДИНАМИЧНА ПАМЕТ                            ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  СТАТИЧНА ПАМЕТ:                                       ║
║    int a = 10;                                         ║
║    • Заделя се ПРИ КОМПИЛАЦИЯ                          ║
║    • Автоматично се освобождава                        ║
║    • Фиксиран размер                                   ║
║                                                        ║
║  ДИНАМИЧНА ПАМЕТ:                                      ║
║    int* p = new int(10);                               ║
║    • Заделя се ПО ВРЕМЕ НА ИЗПЪЛНЕНИЕ                  ║
║    • ТРЯБВА да се освободи с delete                    ║
║    • Променлив размер                                  ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

### 📝 Оператор new

**`new`** заделя памет динамично и връща адрес към нея.

```cpp
// Синтаксис:
тип* указател = new тип;
тип* указател = new тип(стойност);

// Примери:
int* p = new int;         // Заделя памет за 1 int
int* p2 = new int(42);    // Заделя памет и инициализира с 42
double* pd = new double;  // Заделя памет за 1 double
```

### 📝 Оператор delete

**`delete`** освобождава динамично заделената памет.

```cpp
int* p = new int(10);
// ... използваме p ...
delete p;   // Освобождаваме паметта
p = nullptr; // Добра практика!
```

### 🎬 Пълен пример

```cpp
#include <iostream>
using namespace std;

int main() {
    // Заделяме памет за една променлива от тип double
    double* pd = new double;
    
    *pd = 3.14;  // Присвояваме стойност
    
    cout << "Стойност: " << *pd << endl;
    cout << "Адрес: " << pd << endl;
    
    // ВАЖНО: Освобождаваме паметта!
    delete pd;
    pd = nullptr;
    
    return 0;
}
```

### 📊 Визуализация на new и delete

```
═══════════════════════════════════════════════════════════
СТЪПКА 1: double* pd = new double;
═══════════════════════════════════════════════════════════

STACK (автоматична памет):          HEAP (динамична памет):
┌──────────────────┐                ┌──────────────────┐
│ pd = 0x2000      │ ─────────────► │ ??? (неинициализирана)
│ @0x1000          │                │ @0x2000          │
└──────────────────┘                └──────────────────┘

───────────────────────────────────────────────────────────
СТЪПКА 2: *pd = 3.14;
═══════════════════════════════════════════════════════════

STACK:                              HEAP:
┌──────────────────┐                ┌──────────────────┐
│ pd = 0x2000      │ ─────────────► │ 3.14             │
│ @0x1000          │                │ @0x2000          │
└──────────────────┘                └──────────────────┘

───────────────────────────────────────────────────────────
СТЪПКА 3: delete pd;
═══════════════════════════════════════════────════════════

STACK:                              HEAP:
┌──────────────────┐                ┌──────────────────┐
│ pd = 0x2000 ⚠️   │  ─ ─ ─ ─ ─ ─►  │ (ОСВОБОДЕНА)     │
│ @0x1000          │                │ @0x2000          │
└──────────────────┘                └──────────────────┘

⚠️ pd все още съдържа адреса, но паметта е освободена!
   Затова трябва: pd = nullptr;

───────────────────────────────────────────────────────────
СТЪПКА 4: pd = nullptr;
═══════════════════════════════════════════════════════════

STACK:                              HEAP:
┌──────────────────┐                
│ pd = nullptr ✓   │                (Освободена и забравена)
│ @0x1000          │                
└──────────────────┘                

═══════════════════════════════════════════════════════════
```

---

<a name="dynamic-arrays"></a>
## 📌 Динамични масиви

### 🎯 Масиви с new

За да заделим масив динамично:

```cpp
// Синтаксис:
тип* указател = new тип[размер];

// Пример:
int* arr = new int[5];  // Масив от 5 int елемента
```

**ВАЖНО:** За масиви използваме `delete[]` вместо `delete`!

```cpp
int* arr = new int[5];
// ... използваме arr ...
delete[] arr;  // delete[] за масиви!
arr = nullptr;
```

### 🎬 Пълен пример

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Въведете брой елементи: ";
    cin >> n;
    
    // Динамично заделяме масив от n елемента
    int* arr = new int[n];
    
    // Въвеждаме стойности
    cout << "Въведете " << n << " числа:" << endl;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    // Извеждаме стойностите
    cout << "Въведените числа са:" << endl;
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    // ВАЖНО: Освобождаваме паметта!
    delete[] arr;
    arr = nullptr;
    
    return 0;
}
```

### 📊 Визуализация

```
═══════════════════════════════════════════════════════════
int* arr = new int[5];
═══════════════════════════════════════════════════════════

STACK:                              HEAP:
┌──────────────────┐                ┌───┬───┬───┬───┬───┐
│ arr = 0x2000     │ ─────────────► │ 0 │ 1 │ 2 │ 3 │ 4 │
│ @0x1000          │                └───┴───┴───┴───┴───┘
└──────────────────┘                @0x2000 ... @0x2010

arr[0] → елемент на адрес 0x2000
arr[1] → елемент на адрес 0x2004
arr[2] → елемент на адрес 0x2008
...

ОСВОБОЖДАВАНЕ:
delete[] arr;  // Освобождава ВСИЧКИ 5 елемента!

═══════════════════════════════════════════════════════════
```

### ⚠️ Често срещани грешки

```cpp
// ❌ ГРЕШКА 1: delete вместо delete[]
int* arr = new int[5];
delete arr;   // ❌ ГРЕШКА! Освобождава само първия елемент!

// ✅ ПРАВИЛНО
int* arr = new int[5];
delete[] arr; // ✅ Освобождава ЦЕЛИЯ масив

───────────────────────────────────────────────────────────

// ❌ ГРЕШКА 2: Използване след delete
int* arr = new int[5];
delete[] arr;
arr[0] = 10;  // ❌ UNDEFINED BEHAVIOR!

// ✅ ПРАВИЛНО
int* arr = new int[5];
delete[] arr;
arr = nullptr;
// if (arr != nullptr) arr[0] = 10;  ← Няма да се изпълни

───────────────────────────────────────────────────────────

// ❌ ГРЕШКА 3: Двойно delete
int* arr = new int[5];
delete[] arr;
delete[] arr;  // ❌ ГРЕШКА! Двойно освобождаване!

// ✅ ПРАВИЛНО
int* arr = new int[5];
delete[] arr;
arr = nullptr;  // След това delete[] arr е безопасно (нищо не прави)
```

---

<a name="memory-leaks"></a>
## 📌 Memory Leaks (Изтичане на памет)

### 🎯 Какво е Memory Leak?

**Memory leak** е когато заделяме динамична памет но **забравяме** да я освободим.

```cpp
// ❌ MEMORY LEAK!
void badFunction() {
    int* p = new int(10);
    // ... код ...
    // ЗАБРАВИХМЕ: delete p;
}  // p излиза от scope, но паметта остава заделена!
```

### 📊 Визуализация на Memory Leak

```
═══════════════════════════════════════════════════════════
MEMORY LEAK ПРИМЕР:
═══════════════════════════════════════════════════════════

void function() {
    int* p = new int(10);
    // Забравяме delete p;
}

ПРЕДИ ФУНКЦИЯТА:
HEAP: [     празно     ]

СЛЕД int* p = new int(10):
STACK:              HEAP:
┌───────────┐       ┌───────────┐
│ p = 0x200 │ ───►  │ 10        │
└───────────┘       └───────────┘

СЛЕД КРАЯ НА ФУНКЦИЯТА:
STACK:              HEAP:
(празен)            ┌───────────┐
                    │ 10  ⚠️    │ ← Заделена, но недостъпна!
                    └───────────┘
                    MEMORY LEAK!

⚠️ Няма начин да освободим тази памет вече!
   При повторни извиквания → паметта се препълва!

═══════════════════════════════════════════════════════════
```

### 🔴 Последствия

```
╔════════════════════════════════════════════════════════╗
║ КАКВО СТАВА ПРИ MEMORY LEAK?                           ║
╠════════════════════════════════════════════════════════╣
║ ⚠️ Паметта се изчерпва постепенно                      ║
║ ⚠️ Програмата забавя                                   ║
║ ⚠️ Възможен crash при изчерпване на паметта            ║
║ ⚠️ Други програми започват да спират                   ║
╚════════════════════════════════════════════════════════╝
```

### ✅ Как да избегнем Memory Leaks?

```cpp
// 1️⃣ ВИНАГИ delete след new!
void goodFunction1() {
    int* p = new int(10);
    // ... код ...
    delete p;  // ✅ Добре!
    p = nullptr;
}

// 2️⃣ Използвай RAII (Resource Acquisition Is Initialization)
void goodFunction2() {
    // Използвай умни указатели (C++11)
    std::unique_ptr<int> p(new int(10));
    // ... код ...
    // Автоматично се освобождава!
}

// 3️⃣ Проверявай с Valgrind или Address Sanitizer
// valgrind ./program
// g++ -fsanitize=address program.cpp
```

---

<a name="linked-lists"></a>
## 📌 ЧАСТ 3: Свързани списъци (Linked Lists)

### 🎯 Какво е свързан списък?

**Свързан списък** е динамична структура от данни, съставена от **възли** (nodes), където всеки възел съдържа:
- **Данни** (data)
- **Указател** към следващия възел (next)

### 📊 Визуализация

```
═══════════════════════════════════════════════════════════
МАСИВ vs СВЪРЗАН СПИСЪК:
═══════════════════════════════════════════════════════════

МАСИВ:
┌───┬───┬───┬───┬───┐
│ 10│ 20│ 30│ 40│ 50│  ← Елементите са последователни в паметта
└───┴───┴───┴───┴───┘
0x100 0x104 0x108 ...

СВЪРЗАН СПИСЪК:
    ┌────┬────┐     ┌────┬────┐     ┌────┬────┐
    │ 10 │  ──┼────►│ 20 │  ──┼────►│ 30 │NULL│
    └────┴────┘     └────┴────┘     └────┴────┘
    @0x200          @0x300          @0x400
    
    ↑ data + next   ↑ data + next   ↑ data + next

Всеки възел може да е на произволно място в паметта!

═══════════════════════════════════════════════════════════
```

### 📝 Дефиниция на възел (Node)

```cpp
struct Node {
    int data;         // Данните
    Node* next;       // Указател към следващия възел
};

// Създаване на възел:
Node* newNode = new Node;
newNode->data = 10;
newNode->next = nullptr;
```

### 🎬 Пример: Създаване на списък

```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

int main() {
    // Създаваме 3 възела
    Node* head = new Node;    // Първи възел (главата)
    Node* second = new Node;  // Втори възел
    Node* third = new Node;   // Трети възел
    
    // Присвояваме данни
    head->data = 10;
    second->data = 20;
    third->data = 30;
    
    // Свързваме възлите
    head->next = second;
    second->next = third;
    third->next = nullptr;  // Краят на списъка
    
    // Обхождаме списъка
    Node* current = head;
    while (current != nullptr) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "NULL" << endl;
    
    // Освобождаваме паметта
    delete head;
    delete second;
    delete third;
    
    return 0;
}
```

**Изход:**
```
10 -> 20 -> 30 -> NULL
```

### 📊 Стъпка по стъпка визуализация

```
═══════════════════════════════════════════════════════════
СТЪПКА 1: Създаване на възлите
═══════════════════════════════════════════════════════════

Node* head = new Node;
Node* second = new Node;
Node* third = new Node;

    head                second              third
     ↓                    ↓                   ↓
┌────┬────┐         ┌────┬────┐        ┌────┬────┐
│ ?  │ ?  │         │ ?  │ ?  │        │ ?  │ ?  │
└────┴────┘         └────┴────┘        └────┴────┘
@0x200              @0x300             @0x400

───────────────────────────────────────────────────────────
СТЪПКА 2: Присвояване на данни
═══════════════════────────────────────────────════────────

head->data = 10;
second->data = 20;
third->data = 30;

┌────┬────┐         ┌────┬────┐        ┌────┬────┐
│ 10 │ ?  │         │ 20 │ ?  │        │ 30 │ ?  │
└────┴────┘         └────┴────┘        └────┴────┘

───────────────────────────────────────────────────────────
СТЪПКА 3: Свързване на възлите
═══════════════════────────────────────────────────────────

head->next = second;
second->next = third;
third->next = nullptr;

┌────┬────┐         ┌────┬────┐        ┌────┬────┐
│ 10 │  ──┼────────►│ 20 │  ──┼───────►│ 30 │NULL│
└────┴────┘         └────┴────┘        └────┴────┘
   head                second             third

ФИНАЛЕН СПИСЪК:
head → [10] → [20] → [30] → NULL

═══════════════════════════════════════════════════════════
```

### ⚙️ Основни операции

#### 1️⃣ Добавяне в началото (Insert at head)

```cpp
void insertAtHead(Node*& head, int value) {
    Node* newNode = new Node;
    newNode->data = value;
    newNode->next = head;  // Новият възел сочи към старата глава
    head = newNode;        // Новият възел става глава
}

// Визуализация:
// ПРЕДИ:
// head → [20] → [30] → NULL
//
// insertAtHead(head, 10);
//
// СЛЕД:
// head → [10] → [20] → [30] → NULL
```

#### 2️⃣ Добавяне в края (Insert at tail)

```cpp
void insertAtTail(Node*& head, int value) {
    Node* newNode = new Node;
    newNode->data = value;
    newNode->next = nullptr;
    
    if (head == nullptr) {
        head = newNode;  // Списъкът е празен
        return;
    }
    
    // Намираме последния възел
    Node* current = head;
    while (current->next != nullptr) {
        current = current->next;
    }
    current->next = newNode;
}
```

#### 3️⃣ Изтриване на възел

```cpp
void deleteNode(Node*& head, int value) {
    if (head == nullptr) return;
    
    // Ако трябва да изтрием главата
    if (head->data == value) {
        Node* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    
    // Търсим възела преди този който трябва да изтрием
    Node* current = head;
    while (current->next != nullptr && current->next->data != value) {
        current = current->next;
    }
    
    if (current->next != nullptr) {
        Node* temp = current->next;
        current->next = temp->next;
        delete temp;
    }
}
```

#### 4️⃣ Обхождане (Traversal)

```cpp
void printList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "NULL" << endl;
}
```

### 📊 Сложност на операциите

```
┌─────────────────────────┬──────────┬──────────────┐
│ Операция                │ Време    │ Обяснение    │
├─────────────────────────┼──────────┼──────────────┤
│ Insert at head          │ O(1)     │ Директен     │
│ Insert at tail          │ O(n)     │ Обхождане    │
│ Delete (known position) │ O(1)     │ Директен     │
│ Delete (search)         │ O(n)     │ Търсене      │
│ Search                  │ O(n)     │ Линейно      │
│ Access by index         │ O(n)     │ Обхождане    │
└─────────────────────────┴──────────┴──────────────┘
```

---

<a name="stack-queue"></a>
## 📌 Стек и Опашка със свързани списъци

### 🎯 Стек (Stack) - LIFO

**Стек** (stack) е структура данни тип **LIFO** (Last In, First Out) - "последен влязъл, пръв излязъл".

```
╔════════════════════════════════════════════════════════╗
║ СТЕК - Като стек от чинии                              ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║         ┌───────┐                                      ║
║         │   3   │  ← TOP (последен влязъл)            ║
║         ├───────┤                                      ║
║         │   2   │                                      ║
║         ├───────┤                                      ║
║         │   1   │                                      ║
║         └───────┘                                      ║
║                                                        ║
║  push(3) → добавя отгоре                               ║
║  pop()   → взема отгоре (връща 3)                      ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

#### Имплементация:

```cpp
struct Stack {
    Node* top;  // Връх на стека
    
    Stack() {
        top = nullptr;
    }
    
    // Push - добавяне отгоре
    void push(int value) {
        Node* newNode = new Node;
        newNode->data = value;
        newNode->next = top;
        top = newNode;
    }
    
    // Pop - премахване отгоре
    int pop() {
        if (top == nullptr) {
            cout << "Stack е празен!" << endl;
            return -1;
        }
        Node* temp = top;
        int value = temp->data;
        top = top->next;
        delete temp;
        return value;
    }
    
    // Peek - виж без да премахваш
    int peek() {
        if (top == nullptr) return -1;
        return top->data;
    }
    
    // Проверка дали е празен
    bool isEmpty() {
        return top == nullptr;
    }
};
```

### 🎯 Опашка (Queue) - FIFO

**Опашка** (queue) е структура данни тип **FIFO** (First In, First Out) - "първи влязъл, пръв излязъл".

```
╔════════════════════════════════════════════════════════╗
║ ОПАШКА - Като опашка в магазин                         ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  REAR (back)          FRONT                            ║
║     ↓                   ↓                              ║
║  ┌───┬───┬───┬───┬───┐                                 ║
║  │ 5 │ 4 │ 3 │ 2 │ 1 │                                 ║
║  └───┴───┴───┴───┴───┘                                 ║
║    ↑                   ↑                               ║
║  влизат тук        излизат тук                         ║
║                                                        ║
║  enqueue(5) → добавя отзад                             ║
║  dequeue()  → взема отпред (връща 1)                   ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

#### Имплементация:

```cpp
struct Queue {
    Node* front;  // Предната част
    Node* rear;   // Задната част
    
    Queue() {
        front = rear = nullptr;
    }
    
    // Enqueue - добавяне в края
    void enqueue(int value) {
        Node* newNode = new Node;
        newNode->data = value;
        newNode->next = nullptr;
        
        if (rear == nullptr) {
            front = rear = newNode;
            return;
        }
        
        rear->next = newNode;
        rear = newNode;
    }
    
    // Dequeue - премахване от началото
    int dequeue() {
        if (front == nullptr) {
            cout << "Queue е празна!" << endl;
            return -1;
        }
        
        Node* temp = front;
        int value = temp->data;
        front = front->next;
        
        if (front == nullptr)
            rear = nullptr;
        
        delete temp;
        return value;
    }
    
    bool isEmpty() {
        return front == nullptr;
    }
};
```

---

<a name="trees"></a>
## 📌 Двоични дървета (Binary Trees)

### 🎯 Какво е двоично дърво?

**Двоично дърво** е йерархична структура, където всеки възел има **максимум 2 деца**.

```
═══════════════════════════════════════════════════════════
ДВОИЧНО ДЪРВО:
═══════════════════════════════════════════════════════════

                    10  ← ROOT (корен)
                   /  \
                  /    \
                 5      15
                / \    /  \
               3   7  12  20

Терминология:
  • ROOT - коренът (10)
  • PARENT - родител (10 е родител на 5 и 15)
  • CHILDREN - деца (5 и 15 са деца на 10)
  • LEAF - лист, възел без деца (3, 7, 12, 20)
  • SUBTREE - поддърво (лявото поддърво на 10 е 5,3,7)

═══════════════════════════════════════════════════════════
```

### 📝 Дефиниция на възел

```cpp
struct TreeNode {
    int data;
    TreeNode* left;   // Ляво дете
    TreeNode* right;  // Дясно дете
};
```

### 🎬 Създаване на дърво

```cpp
// Създаваме коренния възел
TreeNode* root = new TreeNode;
root->data = 10;

// Създаваме лявото и дясното дете
root->left = new TreeNode;
root->left->data = 5;
root->left->left = nullptr;
root->left->right = nullptr;

root->right = new TreeNode;
root->right->data = 15;
root->right->left = nullptr;
root->right->right = nullptr;
```

### 🔄 Обхождане на дърво

#### 1️⃣ Inorder (Ляво → Корен → Дясно)

```cpp
void inorder(TreeNode* node) {
    if (node == nullptr) return;
    
    inorder(node->left);         // Ляво
    cout << node->data << " ";   // Корен
    inorder(node->right);        // Дясно
}

// За дървото отгоре: 3 5 7 10 12 15 20
```

#### 2️⃣ Preorder (Корен → Ляво → Дясно)

```cpp
void preorder(TreeNode* node) {
    if (node == nullptr) return;
    
    cout << node->data << " ";   // Корен
    preorder(node->left);        // Ляво
    preorder(node->right);       // Дясно
}

// За дървото отгоре: 10 5 3 7 15 12 20
```

#### 3️⃣ Postorder (Ляво → Дясно → Корен)

```cpp
void postorder(TreeNode* node) {
    if (node == nullptr) return;
    
    postorder(node->left);       // Ляво
    postorder(node->right);      // Дясно
    cout << node->data << " ";   // Корен
}

// За дървото отгоре: 3 7 5 12 20 15 10
```

### 📊 Визуализация на обхожданията

```
═══════════════════════════════════════════════════════════
ДЪРВО:
                    10
                   /  \
                  5    15
                 / \   / \
                3   7 12 20

───────────────────────────────────────────────────────────
INORDER (Ляво → Корен → Дясно):
───────────────────────────────────────────────────────────

Стъпки:
  1. Отиваме най-ляво → 3
  2. Връщаме се при родителя → 5
  3. Отиваме надясно → 7
  4. Връщаме се при корена → 10
  5. ...

Резултат: 3, 5, 7, 10, 12, 15, 20  ← СОРТИРАНИ!

───────────────────────────────────────────────────────────
PREORDER (Корен → Ляво → Дясно):
───────────────────────────────────────────────────────────

Стъпки:
  1. Корен → 10
  2. Ляво поддърво → 5, 3, 7
  3. Дясно поддърво → 15, 12, 20

Резултат: 10, 5, 3, 7, 15, 12, 20

───────────────────────────────────────────────────────────
POSTORDER (Ляво → Дясно → Корен):
───────────────────────────────────────────────────────────

Стъпки:
  1. Ляво поддърво → 3, 7, 5
  2. Дясно поддърво → 12, 20, 15
  3. Корен → 10

Резултат: 3, 7, 5, 12, 20, 15, 10

═══════════════════════════════════════════════════════════
```

---

<a name="common-mistakes"></a>
## ⚠️ Често срещани грешки

### 1️⃣ Забравяне на delete

```cpp
// ❌ ГРЕШКА - Memory leak!
void bad() {
    int* p = new int(10);
    // Забравяме: delete p;
}

// ✅ ПРАВИЛНО
void good() {
    int* p = new int(10);
    delete p;
    p = nullptr;
}
```

### 2️⃣ Dangling Pointer (Висящ указател)

```cpp
// ❌ ГРЕШКА!
int* bad() {
    int x = 10;
    return &x;  // Връщаме адрес на локална променлива!
}

// x се унищожава когато функцията приключи!
// Указателят сочи към невалидна памет!

// ✅ ПРАВИЛНО
int* good() {
    int* p = new int(10);
    return p;  // Динамичната памет остава валидна
}
```

### 3️⃣ Използване след delete

```cpp
// ❌ ГРЕШКА!
int* p = new int(10);
delete p;
cout << *p << endl;  // Undefined behavior!

// ✅ ПРАВИЛНО
int* p = new int(10);
delete p;
p = nullptr;
if (p != nullptr) {
    cout << *p << endl;
}
```

### 4️⃣ Неправилно delete за масиви

```cpp
// ❌ ГРЕШКА!
int* arr = new int[5];
delete arr;  // Трябва delete[]!

// ✅ ПРАВИЛНО
int* arr = new int[5];
delete[] arr;
arr = nullptr;
```

### 5️⃣ Изгубен указател

```cpp
// ❌ ГРЕШКА!
int* p = new int(10);
p = new int(20);  // Изгубихме първата памет!

// ✅ ПРАВИЛНО
int* p = new int(10);
delete p;         // Първо освобождаваме
p = new int(20);  // После заделяме ново
```

---

<a name="best-practices"></a>
## ✅ Best Practices (Добри практики)

### 1️⃣ Винаги инициализирай указатели

```cpp
// ❌ Лошо
int* p;  // p съдържа произволна стойност!

// ✅ Добре
int* p = nullptr;  // p е инициализиран
```

### 2️⃣ Провервай за nullptr преди използване

```cpp
if (p != nullptr) {
    *p = 10;  // Безопасно
}
```

### 3️⃣ Задавай nullptr след delete

```cpp
delete p;
p = nullptr;  // Важно!
```

### 4️⃣ Използвай умни указатели (C++11+)

```cpp
#include <memory>

// Auto cleanup!
std::unique_ptr<int> p(new int(10));
// Не е нужен delete!
```

### 5️⃣ Винаги освобождавай паметта в обратен ред

```cpp
Node* a = new Node;
Node* b = new Node;
Node* c = new Node;

// ...

delete c;  // Последен заделен, първи освободен
delete b;
delete a;
```

### 6️⃣ Използвай RAII (Resource Acquisition Is Initialization)

```cpp
class SafeArray {
private:
    int* data;
    int size;
    
public:
    SafeArray(int n) : size(n) {
        data = new int[n];  // Заделяне при създаване
    }
    
    ~SafeArray() {
        delete[] data;      // Автоматично освобождаване
    }
    
    // ...
};
```

---

## 📊 Сравнителна таблица на структурите

```
┌─────────────────┬─────────┬─────────┬─────────┬──────────┐
│ Структура       │ Insert  │ Delete  │ Search  │ Памет    │
├─────────────────┼─────────┼─────────┼─────────┼──────────┤
│ Масив           │ O(n)    │ O(n)    │ O(1)*   │ O(n)     │
│ Свързан списък  │ O(1)**  │ O(1)**  │ O(n)    │ O(n)     │
│ Стек            │ O(1)    │ O(1)    │ O(n)    │ O(n)     │
│ Опашка          │ O(1)    │ O(1)    │ O(n)    │ O(n)     │
│ BST (среден)    │ O(log n)│ O(log n)│ O(log n)│ O(n)     │
└─────────────────┴─────────┴─────────┴─────────┴──────────┘

* при известен индекс
** при известна позиция
```

---

## 🎓 Заключение

### 🌟 Ключови изводи

```
╔════════════════════════════════════════════════════════╗
║ ЩО НАУЧИХМЕ?                                           ║
╚════════════════════════════════════════════════════════╝

✅ УКАЗАТЕЛИ:
   - Какво е адрес в паметта
   - Оператори & и *
   - Декларация и използване

✅ ДИНАМИЧНА ПАМЕТ:
   - new и delete операции
   - Динамични масиви
   - Memory leaks

✅ ДИНАМИЧНИ СТРУКТУРИ:
   - Свързани списъци
   - Стек и опашка
   - Двоични дървета

✅ ДОБРИ ПРАКТИКИ:
   - Винаги delete след new
   - Проверявай за nullptr
   - Задавай nullptr след delete
```

### 💡 Защо са важни указателите?

```
╔════════════════════════════════════════════════════════╗
║ УКАЗАТЕЛИТЕ ПОЗВОЛЯВАТ:                                ║
╠════════════════════════════════════════════════════════╣
║ ✅ Динамично заделяне на памет                         ║
║ ✅ Ефективно предаване на големи структури             ║
║ ✅ Създаване на сложни структури (дървета, графи)     ║
║ ✅ Връщане на множество стойности от функции           ║
║ ✅ Работа с низове и масиви                            ║
╚════════════════════════════════════════════════════════╝
```

### 🚀 Следващи стъпки

След като овладееш указателите:

1. **Референции** (references) в C++
2. **Умни указатели** (smart pointers) - unique_ptr, shared_ptr
3. **Графи** (graphs) - свързани структури
4. **Hash таблици** - бързо търсене
5. **Алгоритми върху дървета** - балансиране, обхождане

---

**🎉 Благодаря че прочете това ръководство!**

Надявам се че сега разбираш НАПЪЛНО как работят указателите и динамичните структури! 🎯

**Успех с програмирането!** 💪

---

*Създадено за студенти, които искат да разберат указателите отблизо!*

