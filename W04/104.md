# 📚 Упражнение № 04: Алгоритми за сортиране

## 🎯 Пълно методическо ръководство с детайлни обяснения

**От Bubble Sort до Heap Sort - всичко обяснено стъпка по стъпка**

---

## 📋 Съдържание

### Основни алгоритми (от задачите):
1. [Bubble Sort](#bubble-sort) - Сортиране чрез размяна (мехурчето)
2. [Selection Sort](#selection-sort) - Сортиране чрез пряк избор
3. [Insertion Sort](#insertion-sort) - Сортиране чрез вмъкване
4. [Quick Sort](#quick-sort) - Бързо сортиране
5. [Merge Sort](#merge-sort) - Сортиране чрез сливане
6. [Heap Sort](#heap-sort) - Сортиране чрез пирамида

### Бонус алгоритми:
7. [Counting Sort](#counting-sort) - Сортиране чрез броене
8. [Bucket Sort](#bucket-sort) - Сортиране чрез кофи
9. [Shell Sort](#shell-sort) - Сортиране чрез интервали

### Допълнително:
- [Сравнителен анализ](#comparison) - Коя сортировка кога да използваме
- [Визуализации стъпка по стъпка](#visualizations) - Как работи всяка сортировка
- [Времева и памета сложност](#complexity) - Big O нотация обяснена просто

---

<a name="bubble-sort"></a>
## 📌 Задача 104-1: Bubble Sort (Метод на мехурчето)

### 🎯 Условие

Сортиране на масив във възходящ ред чрез метода на мехурчето (Bubble Sort).

### 💡 Идея на алгоритъма

**Сортирането** е процес на подреждане на елементите на един масив по големина във възходящ или низходящ ред.

**Принцип на Bubble Sort:**
1. Сравняваме всеки два съседни елемента
2. Ако не са подредени във възходящ ред ги разменяме
3. Повтаряме процеса **n-1** пъти (за n елемента)
4. На всяка стъпка един елемент намира правилното си място

🔑 **Защо 'мехурче'?** 

Най-големият елемент 'изплува' към края на масива като мехурче във вода - на всяка итерация най-големият елемент от несортираната част се премества в края!

### 🔍 Детайлно обяснение на кода

#### **Редове 1-4: Включване на библиотеки**

```cpp
#include <iostream>
using namespace std;
```

Стандартни включвания за вход/изход операции.

#### **Редове 6-8: Декларация на променливи**

```cpp
int n; // брой елементи
int i, j, tempVar; // брояч за външен цикъл, вътрешен цикъл, временна променлива
int arr[50]; // масив с максимум 50 елемента
```

#### **Редове 10-17: Въвеждане на данните**

```cpp
cout << "Please enter the number of elements: ";
cin >> n;

cout << "Please enter the elements of the array: " << endl;
for (i = 0; i < n; i++) {
    cin >> arr[i];
}
```

Въвеждаме броя елементи и самите елементи в масива.

#### **Редове 19-29: ЯДРОТО - Bubble Sort алгоритъм**

```cpp
for (i = 0; i < n - 1; i++) {           // Външен цикъл: n-1 итерации
    for (j = 0; j < n - i - 1; j++) {   // Вътрешен цикъл: сравнява съседни елементи
        if (arr[j] > arr[j + 1]) {      // Ако текущият е по-голям от следващия
            // Размяна (swap)
            tempVar = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = tempVar;
        }
    }
}
```

**Ключови моменти:**

1. **Външен цикъл** `i`: Контролира броя на итерациите (n-1 итерация)
2. **Вътрешен цикъл** `j`: Сравнява съседни двойки елементи
3. **`n - i - 1`**: На всяка итерация последните `i` елемента са вече на място, затова ги пропускаме
4. **Размяна**: Използваме временна променлива `tempVar` за да разменим два елемента

#### **Редове 31-36: Извеждане на резултата**

```cpp
cout << "Sorted array: " << endl;
for (i = 0; i < n; i++) {
    cout << arr[i] << endl;
}
```

### 📊 Визуализация стъпка по стъпка

#### 🎬 Пример: Сортиране на [5, 3, 7, 2, 9]

```
═══════════════════════════════════════════════════════════
НАЧАЛЕН МАСИВ: [5, 3, 7, 2, 9]
Индекси:        0  1  2  3  4
═══════════════════════════════════════════════════════════

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ОБХОЖДАНЕ 1 (i = 0): Най-големият елемент идва в края      ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Стъпка 1: Сравняваме j=0 и j=1
[5, 3, 7, 2, 9]
 ↑  ↑
 5 > 3? ДА → РАЗМЯНА!
Резултат: [3, 5, 7, 2, 9]

Стъпка 2: Сравняваме j=1 и j=2
[3, 5, 7, 2, 9]
    ↑  ↑
    5 > 7? НЕ → БЕЗ размяна
Резултат: [3, 5, 7, 2, 9]

Стъпка 3: Сравняваме j=2 и j=3
[3, 5, 7, 2, 9]
       ↑  ↑
       7 > 2? ДА → РАЗМЯНА!
Резултат: [3, 5, 2, 7, 9]

Стъпка 4: Сравняваме j=3 и j=4
[3, 5, 2, 7, 9]
          ↑  ↑
          7 > 9? НЕ → БЕЗ размяна
Резултат: [3, 5, 2, 7, 9]

След итерация 1: [3, 5, 2, 7, │ 9 ]
                             └──── НА МЯСТО! ✓

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ОБХОЖДАНЕ 2 (i = 1): Втори най-голям елемент на място      ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Стъпка 1: Сравняваме j=0 и j=1
[3, 5, 2, 7, 9]
 ↑  ↑
 3 > 5? НЕ → БЕЗ размяна
Резултат: [3, 5, 2, 7, 9]

Стъпка 2: Сравняваме j=1 и j=2
[3, 5, 2, 7, 9]
    ↑  ↑
    5 > 2? ДА → РАЗМЯНА!
Резултат: [3, 2, 5, 7, 9]

Стъпка 3: Сравняваме j=2 и j=3
[3, 2, 5, 7, 9]
       ↑  ↑
       5 > 7? НЕ → БЕЗ размяна
Резултат: [3, 2, 5, 7, 9]

След итерация 2: [3, 2, 5, │ 7, 9 ]
                         └─────── НА МЯСТО! ✓

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ОБХОЖДАНЕ 3 (i = 2): Трети най-голям елемент на място      ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Стъпка 1: Сравняваме j=0 и j=1
[3, 2, 5, 7, 9]
 ↑  ↑
 3 > 2? ДА → РАЗМЯНА!
Резултат: [2, 3, 5, 7, 9]

Стъпка 2: Сравняваме j=1 и j=2
[2, 3, 5, 7, 9]
    ↑  ↑
    3 > 5? НЕ → БЕЗ размяна
Резултат: [2, 3, 5, 7, 9]

След итерация 3: [2, 3, │ 5, 7, 9 ]
                      └────────── НА МЯСТО! ✓

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ОБХОЖДАНЕ 4 (i = 3): Последна проверка                     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Стъпка 1: Сравняваме j=0 и j=1
[2, 3, 5, 7, 9]
 ↑  ↑
 2 > 3? НЕ → БЕЗ размяна
Резултат: [2, 3, 5, 7, 9]

След итерация 4: [ 2, 3, 5, 7, 9 ] ✅ СОРТИРАН!

═══════════════════════════════════════════════════════════
ФИНАЛЕН РЕЗУЛТАТ: [2, 3, 5, 7, 9]
Брой итерации: 4 (n - 1)
Брой сравнения: 10
Брой размени: 4
═══════════════════════════════════════════════════════════
```

### ⏱️ Времева и памета сложност

```
╔════════════════════════════════════════════════════════╗
║ АНАЛИЗ НА СЛОЖНОСТТА                                   ║
╚════════════════════════════════════════════════════════╝

┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Най-лош случай      │ O(n²)     │ Обратно сортиран    │
│ Среден случай       │ O(n²)     │ Случаен ред         │
│ Най-добър случай    │ O(n)      │ Вече сортиран*      │
│ Памет (Space)       │ O(1)      │ Само временни var   │
│ Стабилност          │ ДА ✓      │ Запазва реда        │
│ In-place            │ ДА ✓      │ Без доп. масиви     │
└─────────────────────┴───────────┴─────────────────────┘

* С оптимизация (флаг за проверка дали има размени)
```

### 📈 Брой операции в детайли

```
За масив с n елемента:

Брой итерации: n - 1

Итерация 1: (n-1) сравнения
Итерация 2: (n-2) сравнения
Итерация 3: (n-3) сравнения
...
Итерация n-1: 1 сравнение

Общо сравнения: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ O(n²)

Пример за n = 5:
4 + 3 + 2 + 1 = 10 сравнения
```

### ✅ Примери за тестване

#### Тест 1: Обратно сортиран (най-лош случай)

```
Вход:
6
5 3 7 9 12 15

Очакван изход:
3 5 7 9 12 15
```

#### Тест 2: Вече сортиран (най-добър случай)

```
Вход:
6
15 12 9 7 5 3

Очакван изход:
3 5 7 9 12 15
```

#### Тест 3: Смесен случай

```
Вход:
5
64 34 25 12 22

Очакван изход:
12 22 25 34 64
```

### 🎯 Кога да използваме Bubble Sort?

✅ **Подходящ за:**
- Малки масиви (< 50 елемента)
- Учебни цели
- Почти сортирани данни (с оптимизация)
- Когато простотата на кода е по-важна от скоростта

❌ **НЕ е подходящ за:**
- Големи масиви (> 1000 елемента)
- Критични по време приложения
- Бази данни и големи обеми данни

### 🔧 Оптимизация: Early exit флаг

```cpp
// Оптимизирана версия с флаг
for (i = 0; i < n - 1; i++) {
    bool swapped = false; // флаг за размяна
    
    for (j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr[j], arr[j + 1]);
            swapped = true; // имаше размяна
        }
    }
    
    // Ако НЯМА размяна, масивът е сортиран!
    if (!swapped) {
        break; // СПИРАМЕ по-рано!
    }
}
```

**Предимство:** За вече сортиран масив → O(n) вместо O(n²)!

---

<a name="selection-sort"></a>
## 📌 Задача 104-2: Selection Sort (Метод на пряк избор)

### 🎯 Условие

Сортиране на масив във възходящ ред чрез метода на пряк избор (Selection Sort).

### 💡 Идея на алгоритъма

**Принцип на Selection Sort:**

1. Намираме **най-малкия** елемент от всички елементи
2. **Разменяме** го с елемента на **първо място**
3. Повтаряме стъпки 1-2 за останалите елементи (без вече подредените)

🎯 **Ключова идея:** На всяка итерация "избираме" (select) най-малкия елемент и го поставяме на правилното му място в началото на масива.

### 🔍 Детайлно обяснение на кода

#### **Редове 19-32: ЯДРОТО - Selection Sort алгоритъм**

```cpp
for (i = 0; i < n - 1; i++) {              // Външен цикъл: n-1 итерации
    minIndex = i;                           // Предполагаме че минимумът е на позиция i
    
    for (j = i + 1; j < n; j++) {          // Вътрешен цикъл: търси минимум в остатъка
        if (arr[j] < arr[minIndex]) {      // Ако намерим по-малък елемент
            minIndex = j;                   // Запаметяваме новия индекс
        }
    }
    
    // Размяна на минималния елемент с елемента на позиция i
    tempVar = arr[minIndex];
    arr[minIndex] = arr[i];
    arr[i] = tempVar;
}
```

**Ключови разлики с Bubble Sort:**
- Bubble Sort прави размени **веднага** при сравнение
- Selection Sort прави **само ЕДНА размяна** на итерация (след като намери минимума)

### 📊 Визуализация стъпка по стъпка

#### 🎬 Пример: Сортиране на [64, 25, 12, 22, 11]

```
═══════════════════════════════════════════════════════════
НАЧАЛЕН МАСИВ: [64, 25, 12, 22, 11]
Индекси:        0   1   2   3   4
═══════════════════════════════════════════════════════════

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ОБХОЖДАНЕ 1 (i = 0): Търсим минимум в целия масив          ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Начало: [64, 25, 12, 22, 11]
         ↑ <── minIndex = 0 (предполагаме 64 е минимум)

Сравняваме с 25: 25 < 64? ДА → minIndex = 1
         [64, 25, 12, 22, 11]
              ↑ <── новият минимум

Сравняваме с 12: 12 < 25? ДА → minIndex = 2
         [64, 25, 12, 22, 11]
                  ↑ <── новият минимум

Сравняваме с 22: 22 < 12? НЕ → minIndex остава 2

Сравняваме с 11: 11 < 12? ДА → minIndex = 4
         [64, 25, 12, 22, 11]
                          ↑ <── финален минимум!

РАЗМЯНА: arr[0] ↔ arr[4]
Преди:   [64, 25, 12, 22, 11]
          ↑               ↑
След:    [11, 25, 12, 22, 64]
          ✓ <── НА МЯСТО!

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ОБХОЖДАНЕ 2 (i = 1): Търсим минимум в остатъка             ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Начало:  [11 │ 25, 12, 22, 64]
          ✓      ↑ <── minIndex = 1 (предполагаме 25 е минимум)

Сравняваме с 12: 12 < 25? ДА → minIndex = 2
         [11, 25, 12, 22, 64]
                  ↑ <── новият минимум

Сравняваме с 22: 22 < 12? НЕ → minIndex остава 2

Сравняваме с 64: 64 < 12? НЕ → minIndex остава 2

РАЗМЯНА: arr[1] ↔ arr[2]
Преди:   [11, 25, 12, 22, 64]
              ↑   ↑
След:    [11, 12, 25, 22, 64]
          ✓   ✓ <── НА МЯСТО!

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ОБХОЖДАНЕ 3 (i = 2): Търсим минимум в остатъка             ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Начало:  [11, 12 │ 25, 22, 64]
          ✓   ✓       ↑ <── minIndex = 2

Сравняваме с 22: 22 < 25? ДА → minIndex = 3
         [11, 12, 25, 22, 64]
                      ↑ <── новият минимум

Сравняваме с 64: 64 < 22? НЕ → minIndex остава 3

РАЗМЯНА: arr[2] ↔ arr[3]
Преди:   [11, 12, 25, 22, 64]
                  ↑   ↑
След:    [11, 12, 22, 25, 64]
          ✓   ✓   ✓ <── НА МЯСТО!

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ОБХОЖДАНЕ 4 (i = 3): Последна проверка                     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Начало:  [11, 12, 22 │ 25, 64]
          ✓   ✓   ✓       ↑ <── minIndex = 3

Сравняваме с 64: 64 < 25? НЕ → minIndex остава 3

РАЗМЯНА: arr[3] ↔ arr[3] (със себе си, няма промяна)

Финално: [11, 12, 22, 25, 64] ✅ СОРТИРАН!

═══════════════════════════════════════════════════════════
ФИНАЛЕН РЕЗУЛТАТ: [11, 12, 22, 25, 64]
Брой итерации: 4 (n - 1)
Брой сравнения: 10
Брой размени: 4 (ПО ЕДНА на итерация!)
═══════════════════════════════════════════════════════════
```

### ⏱️ Времева и памета сложност

```
╔════════════════════════════════════════════════════════╗
║ АНАЛИЗ НА СЛОЖНОСТТА                                   ║
╚════════════════════════════════════════════════════════╝

┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Най-лош случай      │ O(n²)     │ Винаги n² сравнения │
│ Среден случай       │ O(n²)     │ Винаги n² сравнения │
│ Най-добър случай    │ O(n²)     │ Винаги n² сравнения │
│ Памет (Space)       │ O(1)      │ Само tempVar        │
│ Стабилност          │ НЕ ✗      │ Може да промени ред │
│ In-place            │ ДА ✓      │ Без доп. масиви     │
│ Брой размени        │ O(n)      │ Само n-1 размени    │
└─────────────────────┴───────────┴─────────────────────┘

⚠️ ВАЖНО: Selection Sort ВИНАГИ прави n² сравнения,
          дори ако масивът е вече сортиран!
```

### 🔄 Сравнение: Bubble Sort vs Selection Sort

```
┌────────────────────┬─────────────────┬─────────────────┐
│ Характеристика     │  Bubble Sort    │ Selection Sort  │
├────────────────────┼─────────────────┼─────────────────┤
│ Брой размени       │ O(n²)           │ O(n)            │
│ Брой сравнения     │ O(n²)           │ O(n²)           │
│ Оптимизация        │ Възможна (флаг) │ Невъзможна      │
│ Най-добър случай   │ O(n)*           │ O(n²)           │
│ Стабилност         │ ДА ✓            │ НЕ ✗            │
└────────────────────┴─────────────────┴─────────────────┘

* с оптимизация
```

### ✅ Кога да използваме Selection Sort?

✅ **Подходящ за:**
- Когато размените са **скъпа операция** (пр. големи структури)
- Малки масиви
- Когато искаме **минимален брой размени**

❌ **НЕ е подходящ за:**
- Когато нуждаем от **стабилна** сортировка
- Големи масиви
- Когато имаме почти сортирани данни

---


<a name="insertion-sort"></a>
## 📌 Задача 104-3: Insertion Sort (Метод на вмъкването)

### 🎯 Условие

Сортиране на масив във възходящ ред чрез метода на вмъкване (Insertion Sort).

### 💡 Идея на алгоритъма

**Принцип на Insertion Sort:**

Масивът се разделя на две части:
- **Подредена част** (вляво) - започва с 1 елемент
- **Неподредена част** (вдясно) - започва с n-1 елемента

На всяка итерация:
1. Взимаме първия елемент от неподредената част (`key`)
2. Сравняваме го с елементите в подредената част (отдясно наляво)
3. Местим по-големите елементи надясно
4. **Вмъкваме** `key` на правилното му място

🎯 **Ключова аналогия:** Подреждане на карти в ръка - взимаш нова карта и я вмъкваш на правилното място сред вече подредените.

### 🔍 Детайлно обяснение на кода

#### **Ядрото - Insertion Sort алгоритъм**

```cpp
for (int i = 1; i < n; i++) {          // Започваме от втория елемент
    int key = a[i];                     // Елементът за вмъкване
    int j = i - 1;                      // Последен индекс на подредената част
    
    while (j >= 0 && a[j] > key) {     // Докато има по-големи елементи
        a[j + 1] = a[j];                // Местим елемента надясно
        j--;                            // Придвижваме се наляво
    }
    
    a[j + 1] = key;                     // Вмъкваме на свободното място
}
```

**Ключови точки:**
1. `i` започва от 1, защото първият елемент (индекс 0) е "вече подреден"
2. `key` е елементът, който ще вмъкваме
3. `j` се движи назад през подредената част
4. `while` цикъл мести всички по-големи елементи надясно
5. Накрая вмъкваме `key` на освободената позиция

### 📊 Визуализация стъпка по стъпка

#### 🎬 Пример: Сортиране на [9, 5, 2, 7, 1, 4]

```
═══════════════════════════════════════════════════════════
НАЧАЛЕН МАСИВ: [9, 5, 2, 7, 1, 4]
Индекси:        0  1  2  3  4  5
═══════════════════════════════════════════════════════════

Легенда:
│ = граница между подредена и неподредена част
✓ = подредени елементи
? = текущ елемент за вмъкване

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ НАЧАЛО: Първият елемент е "подреден"                    ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Масив: [9 │ 5, 2, 7, 1, 4]
        ✓   └── неподредена част

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ИТЕРАЦИЯ 1 (i = 1): Вмъкваме 5                          ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

key = 5, j = 0

Стъпка 1: [9 │ 5, 2, 7, 1, 4]
           ↑   ?
Сравняваме: a[0] > key? → 9 > 5? ДА!
Действие: Местим 9 надясно → [9, 9, 2, 7, 1, 4]
j-- → j = -1 (стоп!)

Стъпка 2: Вмъкваме key на позиция j+1 = 0
Резултат: [5, 9 │ 2, 7, 1, 4]
           ✓  ✓

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ИТЕРАЦИЯ 2 (i = 2): Вмъкваме 2                          ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

key = 2, j = 1

Сравнения:
  a[1]=9 > 2? ДА → местим 9 надясно
  a[0]=5 > 2? ДА → местим 5 надясно
  j=-1 → стоп!

Резултат: [2, 5, 9 │ 7, 1, 4]
           ✓  ✓  ✓

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ИТЕРАЦИЯ 3 (i = 3): Вмъкваме 7                          ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

key = 7, j = 2

Сравнения:
  a[2]=9 > 7? ДА → местим 9 надясно
  a[1]=5 > 7? НЕ → стоп!

Резултат: [2, 5, 7, 9 │ 1, 4]
           ✓  ✓  ✓  ✓

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ИТЕРАЦИЯ 4 (i = 4): Вмъкваме 1                          ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

key = 1, j = 3

Всички елементи > 1 → местим всички надясно

Резултат: [1, 2, 5, 7, 9 │ 4]
           ✓  ✓  ✓  ✓  ✓

───────────────────────────────────────────────────────────

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ ИТЕРАЦИЯ 5 (i = 5): Вмъкваме 4                          ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

key = 4, j = 4

Местим 9, 7, 5 надясно
Вмъкваме 4 между 2 и 5

Резултат: [1, 2, 4, 5, 7, 9] ✅ СОРТИРАН!

═══════════════════════════════════════════════════════════
ФИНАЛЕН РЕЗУЛТАТ: [1, 2, 4, 5, 7, 9]
Брой итерации: 5 (n - 1)
═══════════════════════════════════════════════════════════
```

### ⏱️ Времева и памета сложност

```
╔════════════════════════════════════════════════════════╗
║ АНАЛИЗ НА СЛОЖНОСТТА                                   ║
╚════════════════════════════════════════════════════════╝

┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Най-лош случай      │ O(n²)     │ Обратно сортиран    │
│ Среден случай       │ O(n²)     │ Случаен ред         │
│ Най-добър случай    │ O(n)      │ Вече сортиран! ✨   │
│ Памет (Space)       │ O(1)      │ Само key и j        │
│ Стабилност          │ ДА ✓      │ Запазва реда        │
│ In-place            │ ДА ✓      │ Без доп. масиви     │
│ Адаптивност         │ ДА ✓      │ Бърз за почти       │
│                     │           │ сортирани данни     │
└─────────────────────┴───────────┴─────────────────────┘

⭐ ВАЖНО: Insertion Sort е МНОГО бърз за почти сортирани
          масиви! Само O(n) в най-добрия случай!
```

### ✅ Кога да използваме Insertion Sort?

✅ **Подходящ за:**
- **Малки масиви** (< 50 елемента)
- **Почти сортирани** данни ⭐⭐⭐
- **Online алгоритми** (данните идват последователно)
- Като част от **Timsort** (Python's sort())

❌ **НЕ е подходящ за:**
- Големи несортирани масиви
- Обратно сортирани данни

---

<a name="quick-sort"></a>
## 📌 Задача 104-4: Quick Sort (Бързо сортиране)

### 🎯 Условие

Сортиране на масив във възходящ ред чрез метода на Quick Sort.

### 💡 Идея на алгоритъма

**Quick Sort** е алгоритъм от типа **"разделяй и владей"** (divide and conquer).

**Основни стъпки:**

1. **Избор на pivot** (опорен елемент) - обикновено средният елемент
2. **Partitioning** (разделяне):
   - Преподреждаме масива така че:
     - Елементи **< pivot** → отиват **вляво**
     - Елементи **> pivot** → отиват **вдясно**
3. **Рекурсивно сортиране** на лявата и дясната част

🎯 **Ключова идея:** След partitioning, pivot е на **правилното си място**!

### 📊 Визуализация

```
═══════════════════════════════════════════════════════════
Пример: [8, 3, 6, 2, 10, 5, 1]
═══════════════════════════════════════════════════════════

            [8,3,6,2,10,5,1]
                  │
          pivot=2 │ partition
           ┌──────┴──────┐
           │             │
        [1,2]      [6,3,10,5,8]
                        │
                pivot=10│partition
                  ┌─────┴─────┐
                  │           │
            [6,3,5,8]      [10]
                  │
            pivot=5 │
              ┌─────┴─────┐
              │           │
            [3]       [6,8]

ФИНАЛЕН РЕЗУЛТАТ: [1, 2, 3, 5, 6, 8, 10] ✅
```

### ⏱️ Сложност

```
┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Среден случай       │ O(n log n)│ Балансирано делене  │
│ Най-лош случай      │ O(n²)     │ Вече сортиран       │
│ Памет               │ O(log n)  │ Рекурсивен стек     │
│ Стабилност          │ НЕ ✗      │ Дълги размени       │
└─────────────────────┴───────────┴─────────────────────┘

⚡ НАЙ-БЪРЗ на практика за повечето случаи!
```

---

<a name="merge-sort"></a>
## 📌 Задача 104-5: Merge Sort (Сортиране чрез сливане)

### 🎯 Условие

Сортиране на масив във възходящ ред чрез метода на сливане (Merge Sort).

### 💡 Идея на алгоритъма

**Merge Sort** е алгоритъм от типа **"разделяй и владей"**.

**Основни стъпки:**
1. **DIVIDE**: Разделяме масива на две равни половини
2. **CONQUER**: Рекурсивно сортираме всяка половина
3. **MERGE**: Сливаме двете сортирани половини

🎯 **Ключова идея:** Лесно е да слеем ДВА сортирани масива в един!

### 📊 Визуализация

```
═══════════════════════════════════════════════════════════
Пример: [12, 7, 9, 3, 15]
═══════════════════════════════════════════════════════════

РАЗДЕЛЯЙ (↓)                    СЛЕЙ (↑)
════════════                    ════════

    [12,7,9,3,15]           [3,7,9,12,15] ← Финал
         ↓                         ↑
    ┌────┴────┐             ┌─────┴─────┐
[12,7,9]   [3,15]      [7,9,12]    [3,15]
    ↓         ↓             ↑           ↑
 ┌──┴──┐      ↓         ┌───┴──┐    ┌───┴──┐
[12,7] [9]            [7,12]  [9]  [3]   [15]
 ↓  ↓                  ↑  ↑
[12][7]              [12][7]

═══════════════════════════════════════════════════════════
```

### ⏱️ Сложност

```
┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Всички случаи       │ O(n log n)│ ВИНАГИ!             │
│ Памет               │ O(n)      │ Временни масиви     │
│ Стабилност          │ ДА ✓      │ Запазва реда        │
└─────────────────────┴───────────┴─────────────────────┘

⭐ Гарантирано O(n log n) + Стабилност!
```

---

<a name="heap-sort"></a>
## 📌 Задача 104-6: Heap Sort (Сортиране чрез пирамида)

### 🎯 Условие

Сортиране на масив във възходящ ред чрез метода на пирамидата (Heap Sort).

### 💡 Идея на алгоритъма

**Heap Sort** използва структурата **"двоична пирамида"** (binary heap).

**Основни стъпки:**
1. **Build Max-Heap**: Превръщаме масива в max-heap
2. **Extract Max**: n-1 пъти:
   - Взимаме корена (максимумът)
   - Слагаме го в края
   - Намаляваме heap-а
   - Възстановяваме heap свойството

🎯 **Ключова идея:** Max-heap ни дава максимума за O(1)!

### 🌳 Представяне като дърво

```
═══════════════════════════════════════════════════════════
Масив:  [20, 15, 30, 5, 10, 25]
Индекси: 0   1   2  3   4   5

ДЪРВО:
                   20 (i=0)
                  /  \
                15    30
               /  \   /
              5   10 25

ФОРМУЛИ:
  Родител на i:      (i - 1) / 2
  Ляво дете на i:    2*i + 1
  Дясно дете на i:   2*i + 2
═══════════════════════════════════════════════════════════
```

### ⏱️ Сложност

```
┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Всички случаи       │ O(n log n)│ ВИНАГИ!             │
│ Памет               │ O(1)      │ In-place! ⭐⭐⭐      │
│ Стабилност          │ НЕ ✗      │ Дълги размени       │
└─────────────────────┴───────────┴─────────────────────┘

⭐ Гарантирано O(n log n) с O(1) памет!
```

---

## 🎁 БОНУС АЛГОРИТМИ

Ето още 3 интересни алгоритъма за сортиране!

<a name="counting-sort"></a>
## 📌 БОНУС 1: Counting Sort (Сортиране чрез броене)

### 🎯 Идея

**Counting Sort** НЕ е сортировка чрез сравнения! 

**Принцип:**
1. Броим колко пъти се среща всяка стойност
2. Изграждаме "cumulative count" (кумулативна сума)
3. Поставяме всеки елемент на правилното му място

🎯 **Ключова идея:** Ако знаем че има 3 елемента <= 5, значи 5-ката трябва да е на позиция 3!

### 📊 Визуализация

```
═══════════════════════════════════════════════════════════
Пример: Сортиране на [4, 2, 2, 8, 3, 3, 1]
═══════════════════════════════════════════════════════════

Стъпка 1: БРОЕНЕ
Масив: [4, 2, 2, 8, 3, 3, 1]

cnt[0] = 0
cnt[1] = 1  (един път има 1)
cnt[2] = 2  (два пъти има 2)
cnt[3] = 2  (два пъти има 3)
cnt[4] = 1  (един път има 4)
cnt[5] = 0
cnt[6] = 0
cnt[7] = 0
cnt[8] = 1  (един път има 8)

Стъпка 2: ИЗГРАЖДАНЕ НА РЕЗУЛТАТА
k = 0
v = 0: cnt[0] = 0 → пропускаме
v = 1: cnt[1] = 1 → a[0] = 1, k = 1
v = 2: cnt[2] = 2 → a[1] = 2, a[2] = 2, k = 3
v = 3: cnt[3] = 2 → a[3] = 3, a[4] = 3, k = 5
v = 4: cnt[4] = 1 → a[5] = 4, k = 6
v = 8: cnt[8] = 1 → a[6] = 8, k = 7

Резултат: [1, 2, 2, 3, 3, 4, 8] ✅
═══════════════════════════════════════════════════════════
```

### ⏱️ Сложност

```
┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Времева сложност    │ O(n + k)  │ n=елементи, k=range │
│ Памет               │ O(k)      │ cnt[] масив         │
│ Стабилност          │ ДА ✓*     │ *в разширена версия │
└─────────────────────┴───────────┴─────────────────────┘

⚡ ВАЖНО: За малък диапазон k (напр. 0-100), Counting Sort е
          ЛИНЕЕН O(n)! По-бърз от всички O(n log n) алгоритми!
```

### ✅ Кога да използваме?

✅ **Подходящ за:**
- **Малък диапазон** на стойности (0-1000)
- **Цели числа**
- Когато n е голямо, но k е малко

❌ **НЕ е подходящ за:**
- Голям диапазон (напр. 0-1000000)
- Реални числа
- Отрицателни числа (без адаптация)

---

<a name="bucket-sort"></a>
## 📌 БОНУС 2: Bucket Sort (Сортиране чрез кофи)

### 🎯 Идея

**Bucket Sort** разпределя елементите в "кофи" (buckets) според техния диапазон.

**Принцип:**
1. Разделяме диапазона на k равни части (кофи)
2. Разпределяме елементите по кофите
3. Сортираме всяка кофа (с друга сортировка)
4. Сливаме кофите

### 📊 Визуализация

```
═══════════════════════════════════════════════════════════
Пример: [29, 25, 3, 49, 9, 37, 21, 43]
min = 3, max = 49, диапазон = 46, брой кофи = 5
═══════════════════════════════════════════════════════════

Стъпка 1: РАЗПРЕДЕЛЯНЕ ПО КОФИ

Кофа 0 [3-12]:   [3, 9]
Кофа 1 [13-22]:  [21]
Кофа 2 [23-32]:  [29, 25]
Кофа 3 [33-42]:  [37]
Кофа 4 [43-49]:  [49, 43]

Стъпка 2: СОРТИРАНЕ НА ВСЯКА КОФА (Insertion Sort)

Кофа 0: [3, 9] → вече сортирана
Кофа 1: [21] → само 1 елемент
Кофа 2: [29, 25] → [25, 29]
Кофа 3: [37] → само 1 елемент
Кофа 4: [49, 43] → [43, 49]

Стъпка 3: СЛИВАНЕ

[3, 9] + [21] + [25, 29] + [37] + [43, 49]
= [3, 9, 21, 25, 29, 37, 43, 49] ✅

═══════════════════════════════════════════════════════════
```

### ⏱️ Сложност

```
┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Среден случай       │ O(n + k)  │ При равномерно      │
│                     │           │ разпределение       │
│ Най-лош случай      │ O(n²)     │ Всички в 1 кофа     │
│ Памет               │ O(n + k)  │ k кофи              │
└─────────────────────┴───────────┴─────────────────────┘

⚡ ВАЖНО: Bucket Sort е ОТЛИЧЕН за равномерно разпределени данни!
```

### ✅ Кога да използваме?

✅ **Подходящ за:**
- **Равномерно разпределени** данни
- Реални числа с float/double
- Големи n, когато данните са "разпръснати"

❌ **НЕ е подходящ за:**
- Неравномерно разпределени данни
- Много дубликати

---

<a name="shell-sort"></a>
## 📌 БОНУС 3: Shell Sort (Сортиране чрез интервали)

### 🎯 Идея

**Shell Sort** е подобрение на **Insertion Sort**.

**Принцип:**
- Insertion Sort е бърз за ПОЧТИ сортирани масиви
- Shell Sort прави масива "почти сортиран" чрез сортиране с голям gap (интервал)
- След това намалява gap-а до 1

🎯 **Ключова идея:** Сортирай с gap = n/2, след това gap = n/4, ... gap = 1

### 📊 Визуализация

```
═══════════════════════════════════════════════════════════
Пример: [12, 34, 54, 2, 3]
n = 5
═══════════════════════════════════════════════════════════

ИТЕРАЦИЯ 1: gap = 5/2 = 2

Сортираме елементи на разстояние 2:
  Подмасив 1: [12, 54, 3]  (индекси 0, 2, 4)
  Подмасив 2: [34, 2]      (индекси 1, 3)

Сортирай подмасив 1: [12, 54, 3] → [3, 12, 54]
Сортирай подмасив 2: [34, 2] → [2, 34]

След gap=2: [3, 2, 12, 34, 54]

───────────────────────────────────────────────────────────

ИТЕРАЦИЯ 2: gap = 2/2 = 1

Това е обикновен Insertion Sort!
Но масивът вече е ПОЧТИ сортиран: [3, 2, 12, 34, 54]

Сортирай с gap=1: [3, 2, 12, 34, 54] → [2, 3, 12, 34, 54]

ФИНАЛЕН РЕЗУЛТАТ: [2, 3, 12, 34, 54] ✅

═══════════════════════════════════════════════════════════
Защо е по-бърз от Insertion Sort?
═══════════════════════════════════════════════════════════

Insertion Sort прави малки стъпки:
  [12, 34, 54, 2, 3]
   → премести 2 от позиция 3 на позиция 0 (3 размени!)
   
Shell Sort прави големи "скокове":
  gap=2 → бързо премества далечни елементи
  gap=1 → само фино настройва (малко работа!)
  
Общ резултат: ПО-МАЛКО операции!
═══════════════════════════════════════════════════════════
```

### ⏱️ Сложност

```
┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Времева сложност    │ O(n^1.5)  │ Зависи от gap       │
│                     │ до O(n²)  │ последователност    │
│ Памет               │ O(1)      │ In-place            │
│ Стабилност          │ НЕ ✗      │ Дълги размени       │
└─────────────────────┴───────────┴─────────────────────┘

⚡ ВАЖНО: Shell Sort е ПО-БЪРЗ от Insertion Sort,
          но ПО-БАВЕН от Quick/Merge/Heap Sort
```

### ✅ Кога да използваме?

✅ **Подходящ за:**
- Средни масиви (100-5000 елемента)
- Когато искаме прост in-place алгоритъм
- По-добра алтернатива на Insertion Sort

❌ **НЕ е подходящ за:**
- Големи масиви (използвай Quick/Merge Sort)
- Когато трябва O(n log n) гаранция

---

<a name="comparison"></a>
## 📊 ЕПИЧНО СРАВНЕНИЕ НА ВСИЧКИ АЛГОРИТМИ

### 🏆 Таблица на сложността

```
╔════════════════════════════════════════════════════════════════════════════╗
║                    СРАВНИТЕЛНА ТАБЛИЦА                                     ║
╚════════════════════════════════════════════════════════════════════════════╝

┌──────────────┬────────┬────────┬────────┬────────┬────────┬────────┬──────┐
│  Алгоритъм   │ Най-   │ Среден │ Най-   │ Памет  │Стабил- │In-place│ Забе-│
│              │ добър  │ случай │ лош    │        │ност    │        │лежки │
├──────────────┼────────┼────────┼────────┼────────┼────────┼────────┼──────┤
│ Bubble Sort  │ O(n)*  │ O(n²)  │ O(n²)  │ O(1)   │ ДА ✓   │ ДА ✓   │  1   │
│ Selection    │ O(n²)  │ O(n²)  │ O(n²)  │ O(1)   │ НЕ ✗   │ ДА ✓   │  2   │
│ Insertion    │ O(n)   │ O(n²)  │ O(n²)  │ O(1)   │ ДА ✓   │ ДА ✓   │  3   │
│ Quick Sort   │O(nlogn)│O(nlogn)│ O(n²)  │O(log n)│ НЕ ✗   │ ДА ✓   │  4   │
│ Merge Sort   │O(nlogn)│O(nlogn)│O(nlogn)│ O(n)   │ ДА ✓   │ НЕ ✗   │  5   │
│ Heap Sort    │O(nlogn)│O(nlogn)│O(nlogn)│ O(1)   │ НЕ ✗   │ ДА ✓   │  6   │
│ Counting**   │ O(n+k) │ O(n+k) │ O(n+k) │ O(k)   │ ДА ✓   │ НЕ ✗   │  7   │
│ Bucket**     │ O(n+k) │ O(n+k) │ O(n²)  │ O(n+k) │ ДА ✓*  │ НЕ ✗   │  8   │
│ Shell Sort   │O(nlogn)│O(n^1.5)│ O(n²)  │ O(1)   │ НЕ ✗   │ ДА ✓   │  9   │
└──────────────┴────────┴────────┴────────┴────────┴────────┴────────┴──────┘

* с оптимизация (early exit флаг)
** НЕ е comparison-based sort (не сравнява елементи)

Забележки:
1. Много прост, учебна цел
2. Минимален брой размени O(n)
3. Отличен за почти сортирани данни
4. НАЙ-БЪРЗ на практика за произволни данни
5. Отличен за външни сортировки, паралелизация
6. Гарантирано O(n log n) с O(1) памет
7. Линеен за малък диапазон k
8. Отличен за равномерно разпределени данни
9. Подобрение на Insertion Sort
```

### 🎯 Кога какво да използваме?

```
╔════════════════════════════════════════════════════════╗
║ ПРАКТИЧЕСКИ СЪВЕТИ                                     ║
╚════════════════════════════════════════════════════════╝

┌────────────────────────────────────────────────────────┐
│ РАЗМЕР НА МАСИВА                                       │
├────────────────────────────────────────────────────────┤
│ n < 10:        Insertion Sort                          │
│ 10 < n < 50:   Insertion Sort или Shell Sort           │
│ 50 < n < 1000: Quick Sort или Shell Sort               │
│ n > 1000:      Quick Sort, Merge Sort или Heap Sort    │
└────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────┐
│ СЪСТОЯНИЕ НА ДАННИТЕ                                   │
├────────────────────────────────────────────────────────┤
│ Вече сортирани:      Insertion Sort O(n)!              │
│ Почти сортирани:     Insertion Sort или Shell Sort     │
│ Обратно сортирани:   Quick Sort или Merge Sort         │
│ Случайни:            Quick Sort (най-бърз)             │
└────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────┐
│ СПЕЦИАЛНИ ИЗИСКВАНИЯ                                   │
├────────────────────────────────────────────────────────┤
│ Трябва стабилност:      Merge Sort или Insertion       │
│ Ограничена памет:       Heap Sort или Quick Sort       │
│ Гарантирано O(n log n): Merge Sort или Heap Sort       │
│ Най-бърза скорост:      Quick Sort                     │
│ Малък диапазон:         Counting Sort O(n+k)           │
│ Реални числа [0,1]:     Bucket Sort                    │
└────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────┐
│ ТИП ДАННИ                                              │
├────────────────────────────────────────────────────────┤
│ Масиви:           Quick Sort                           │
│ Свързани списъци: Merge Sort                           │
│ Външни файлове:   Merge Sort (external sort)          │
│ Цели числа [0,k]: Counting Sort                        │
│ Дробни [0,1]:     Bucket Sort                          │
└────────────────────────────────────────────────────────┘
```

### 🚀 Модерни хибридни алгоритми

```
╔════════════════════════════════════════════════════════╗
║ КАКВО ИЗПОЛЗВАТ РЕАЛНИТЕ ЕЗИЦИ                         ║
╚════════════════════════════════════════════════════════╝

┌────────────────────────────────────────────────────────┐
│ TIMSORT (Python, Java)                                 │
├────────────────────────────────────────────────────────┤
│ Комбинация от:                                         │
│   - Merge Sort (основа)                                │
│   - Insertion Sort (малки части)                       │
│   - Интелигентен merge (използва естествени runs)      │
│                                                        │
│ Характеристики:                                        │
│   - Стабилен ✓                                         │
│   - O(n) за почти сортирани                            │
│   - O(n log n) в най-лош случай                        │
│   - Отличен за реални данни                            │
└────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────┐
│ INTROSORT (C++ std::sort)                              │
├────────────────────────────────────────────────────────┤
│ Комбинация от:                                         │
│   - Quick Sort (начало)                                │
│   - Heap Sort (ако рекурсията е твърде дълбока)        │
│   - Insertion Sort (малки части < 16 елемента)         │
│                                                        │
│ Характеристики:                                        │
│   - НЕ е стабилен ✗                                    │
│   - Гарантирано O(n log n)                             │
│   - СУПЕР БЪРЗ на практика                             │
│   - Най-добрият general-purpose алгоритъм              │
└────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────┐
│ PDQSORT (Pattern-defeating Quicksort)                  │
├────────────────────────────────────────────────────────┤
│ Подобрение на Quick Sort:                              │
│   - Block partitioning                                 │
│   - Heap Sort fallback                                 │
│   - Insertion Sort за малки части                      │
│                                                        │
│ Използва се в: Rust, неки C++ библиотеки              │
└────────────────────────────────────────────────────────┘
```

### 📈 Графично сравнение на скоростта

```
═══════════════════════════════════════════════════════════
ВРЕМЕ ЗА СОРТИРАНЕ НА 10,000 ЕЛЕМЕНТА (случайни)
═══════════════════════════════════════════════════════════

Bubble Sort     ████████████████████████████████ 45 сек
Selection Sort  ████████████████████████████████ 43 сек
Insertion Sort  ██████████████████████████       30 сек
Shell Sort      ███████                           8 сек
Heap Sort       ███                               3 сек
Merge Sort      ██                                2 сек
Quick Sort      █                                 1 сек ⚡
                └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─→
                0  5  10 15 20 25 30 35 40 45 50 секунди

═══════════════════════════════════════════════════════════
ВРЕМЕ ЗА СОРТИРАНЕ НА 1,000,000 ЕЛЕМЕНТА
═══════════════════════════════════════════════════════════

Bubble Sort     НЯМА ДА СВЪРШИ (~ 50 часа!) ⏰
Selection Sort  НЯМА ДА СВЪРШИ (~ 48 часа!) ⏰
Insertion Sort  НЯМА ДА СВЪРШИ (~ 30 часа!) ⏰
Shell Sort      ████████████████              ~15 мин
Heap Sort       ███                            ~3 мин
Merge Sort      ██                             ~2 мин
Quick Sort      █                              ~1 мин ⚡
Counting Sort*  █                              ~1 сек ⚡⚡⚡
                └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─→
                0  2  4  6  8  10 12 14 16 минути

* за диапазон 0-10000

═══════════════════════════════════════════════════════════
```

---

## 🎓 ЗАКЛЮЧЕНИЕ

### 🌟 Ключови изводи

```
╔════════════════════════════════════════════════════════╗
║ ЩО НАУЧИХМЕ?                                           ║
╚════════════════════════════════════════════════════════╝

✅ ПРОСТИ АЛГОРИТМИ (O(n²)):
   - Bubble Sort    → Учебна цел, прост код
   - Selection Sort → Минимални размени
   - Insertion Sort → Отличен за почти сортирани данни!

✅ БЪРЗИ АЛГОРИТМИ (O(n log n)):
   - Quick Sort  → НАЙ-БЪРЗ на практика ⚡
   - Merge Sort  → Стабилен, гарантиран O(n log n)
   - Heap Sort   → O(1) памет, гарантиран O(n log n)

✅ СПЕЦИАЛНИ АЛГОРИТМИ:
   - Counting Sort → O(n) за малък диапазон!
   - Bucket Sort   → O(n) за равномерни данни!
   - Shell Sort    → Подобрение на Insertion Sort

✅ ХИБРИДНИ (реални приложения):
   - Timsort   → Python, Java
   - Introsort → C++ std::sort
   - PDQsort   → Rust
```

### 💡 Практически съвети

1. **За учебни цели:** Започни с Bubble Sort, разбери идеята
2. **За малки масиви (< 50):** Insertion Sort
3. **За общ случай:** Quick Sort
4. **Когато трябва стабилност:** Merge Sort
5. **Когато паметта е ограничена:** Heap Sort
6. **За почти сортирани данни:** Insertion Sort
7. **За цели числа с малък диапазон:** Counting Sort

### 🚀 Следващи стъпки

След като овладеете тези алгоритми:

1. **Анализ на сложността** - Big O нотация в дълбочина
2. **Структури от данни** - Heap, BST, Hash Table
3. **Динамично програмиране** - Мемоизация, оптимизация
4. **Графови алгоритми** - DFS, BFS, Dijkstra
5. **Външни сортировки** - За данни, които не се побират в паметта

---

## 📚 Бърз справочник

### Формули за сложност

```
O(1)        → Константно време     (най-добро)
O(log n)    → Логаритмично време
O(n)        → Линейно време
O(n log n)  → Linearithmic време   (добро)
O(n²)       → Квадратично време     (бавно)
O(n³)       → Кубично време         (много бавно)
O(2^n)      → Експоненциално време (най-лошо)
```

### Индекси за heap в масив

```
Родител на i:     (i - 1) / 2
Ляво дете на i:   2*i + 1
Дясно дете на i:  2*i + 2
```

### Когато да използваме swap

```cpp
// Стандартен swap с temp
int temp = a;
a = b;
b = temp;

// С XOR (без temp, но само за цели числа)
a ^= b;
b ^= a;
a ^= b;

// C++ built-in
swap(a, b);
```

---

**🎉 Благодаря че прочете това ръководство!**

Надявам се че сега имаш ясна представа за ВСИЧКИ алгоритми за сортиране и кога да използваш кой! 🚀

**Успех с програмирането!** 💪

---

*Създадено за студенти, които искат да разберат сортировките отблизо!*

�══
ФИНАЛЕН РЕЗУЛТАТ: [5, 10, 15, 20, 25, 30] ✅
═══════════════════════════════════════════════════════════
```

### ⏱️ Времева и памета сложност

```
╔════════════════════════════════════════════════════════╗
║ АНАЛИЗ НА СЛОЖНОСТТА                                   ║
╚════════════════════════════════════════════════════════╝

┌─────────────────────┬───────────┬─────────────────────┐
│ Характеристика      │ Стойност  │ Обяснение           │
├─────────────────────┼───────────┼─────────────────────┤
│ Най-лош случай      │ O(n log n)│ ВИНАГИ!             │
│ Среден случай       │ O(n log n)│ ВИНАГИ!             │
│ Най-добър случай    │ O(n log n)│ ВИНАГИ!             │
│ Памет (Space)       │ O(1)      │ In-place! ⭐⭐⭐      │
│ Стабилност          │ НЕ ✗      │ Дълги размени       │
│ In-place            │ ДА ✓      │ Без доп. масиви     │
│ Предвидимост        │ ⭐⭐⭐⭐⭐    │ Гарантирано!        │
└─────────────────────┴───────────┴─────────────────────┘

⭐ ВАЖНО: Heap Sort комбинира НАЙ-ДОБРОТО от двата свята:
          - O(n log n) ВИНАГИ (като Merge Sort)
          - O(1) extra space (като Quick Sort)
```

### 🏆 Сравнение на топ 3 алгоритмите

```
┌──────────────┬────────────┬────────────┬────────────┐
│              │ Quick Sort │ Merge Sort │ Heap Sort  │
├──────────────┼────────────┼────────────┼────────────┤
│ Среден случай│ O(n log n) │ O(n log n) │ O(n log n) │
│ Най-лош      │ O(n²) ⚠️    │ O(n log n) │ O(n log n) │
│ Памет        │ O(log n)   │ O(n) ⚠️     │ O(1) ✅    │
│ Стабилност   │ НЕ         │ ДА ✅      │ НЕ         │
│ Скорост      │ ⚡⚡⚡⚡⚡     │ ⚡⚡⚡       │ ⚡⚡⚡       │
│ Предвидимост │ ⚠️          │ ✅         │ ✅         │
└──────────────┴────────────┴────────────┴────────────┘

ЗАКЛЮЧЕНИЕ:
  Quick Sort → Най-бърз на практика
  Merge Sort → Стабилен, добър за външни сортировки
  Heap Sort  → Гарантирано O(n log n) с O(1) памет!
```

### ✅ Кога да използваме Heap Sort?

✅ **Подходящ за:**
- **Ограничена памет** (O(1) extra space!) ⭐⭐⭐
- **Гарантирана скорост** O(n log n)
- **Embedded системи**
- **Real-time системи** (предвидимо време)

❌ **НЕ е подходящ за:**
- Когато трябва **стабилна** сортировка
- Когато Quick Sort е достатъчно бърз
- Малки масиви

### 💡 Практическо приложение

```
Heap Sort се използва в:
1. Priority Queue - структура данни heap
2. Real-time системи - гарантирана сложност
3. Embedded системи - малко памет
4. К-ти най-голям елемент - частична сортировка
5. Медиана от поток данни

Причина: Гарантирано O(n log n) + O(1) памет!
```

---

